<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Ampersand.js, Javascript, ampersand, Node.js, Apps, HTML5">
    <meta name="author" content="Get started with Ampersand.js">
    <title>Ampersand.js - Documentation</title>
    <link rel="stylesheet" href="//cloud.typography.com/7773252/613684/css/fonts.css">
    <link rel="stylesheet" href="/static/css/plugins/normalize.css">
    <link rel="stylesheet" href="/static/css/main.css">
  </head>
  <body class="docs-page">
    <nav class="nav-main cf"><a href="/" class="logo logo-ampersand">Ampersand.js</a><a href="/learn" class="nav-item">Learn</a><a href="/docs" class="nav-item">Docs</a><a href="http://tools.ampersandjs.com" class="nav-item external">Find Modules</a><a href="/contribute" class="nav-item">Contribute</a><a href="/docs" class="button button-primary">Get Started</a></nav>
    <div class="docs cf">
      <nav class="nav-docs"><a href="/" class="logo logo-ampersand"></a><a href="#intro" class="section-top">Introduction</a><a href="#ampersand" class="section-top">ampersand.js app scaffolding</a><a href="#ampersand-defaults" class="section-sub">Defaults</a><a href="#ampersand-state" class="section-top">ampersand-state</a><a href="#ampersand-state-install" class="section-sub">Install</a><a href="#ampersand-state-api-reference" class="section-sub">API Reference</a><a href="#ampersand-state-extend" class="section-sub-sub">extend <code>AmpersandState.extend({ })</code></a><a href="#ampersand-state-constructorinitialize" class="section-sub-sub">constructor/initialize <code>new AmpersandState([attrs], [options])</code></a><a href="#ampersand-state-extraproperties" class="section-sub-sub">extraProperties <code>AmpersandState.extend({ extraProperties: &#39;allow&#39; })</code></a><a href="#ampersand-state-datatypes" class="section-sub-sub">dataTypes</a><a href="#ampersand-state-props" class="section-sub-sub">props <code>AmpersandView.extend({ props: { name: &#39;string&#39; } })</code></a><a href="#ampersand-state-session" class="section-sub-sub">session <code>AmpersandView.extend({ session: { name: &#39;string&#39; } })</code></a><a href="#ampersand-state-derived" class="section-sub-sub">derived</a><a href="#ampersand-state-children" class="section-sub-sub">children <code>AmpersandState.extend({ children: { profile: Profile } })</code></a><a href="#ampersand-state-parse" class="section-sub-sub">parse</a><a href="#ampersand-state-serialize" class="section-sub-sub">serialize <code>state.serialize()</code></a><a href="#ampersand-state-get" class="section-sub-sub">get <code>state.get(attribute); state[attribute]; state.firstName</code></a><a href="#ampersand-state-set" class="section-sub-sub">set <code>state.set(attributes, [options]); state.firstName = &#39;Henrik&#39;;</code></a><a href="#ampersand-state-unset" class="section-sub-sub">unset <code>state.unset(attribute, [options])</code></a><a href="#ampersand-state-toggle" class="section-sub-sub">toggle <code>state.toggle(&#39;active&#39;)</code></a><a href="#ampersand-state-previousattributes" class="section-sub-sub">previousAttributes <code>state.previousAttributes()</code></a><a href="#ampersand-state-haschanged" class="section-sub-sub">hasChanged <code>state.hasChanged([attribute])</code></a><a href="#ampersand-state-changedattributes" class="section-sub-sub">changedAttributes <code>state.changedAttributes([objectToDiff])</code></a><a href="#ampersand-state-tojson" class="section-sub-sub">toJSON <code>state.toJSON()</code></a><a href="#ampersand-model" class="section-top">ampersand-model</a><a href="#ampersand-model-installing" class="section-sub">Installing</a><a href="#ampersand-model-observing" class="section-sub">Observing</a><a href="#ampersand-model-api-reference" class="section-sub">API Reference</a><a href="#ampersand-model-extend" class="section-sub-sub">extend <code>AmpersandModel.extend({ })</code></a><a href="#ampersand-model-idattribute" class="section-sub-sub">idAttribute <code>model.idAttribute</code></a><a href="#ampersand-model-getid" class="section-sub-sub">getId <code>model.getId()</code></a><a href="#ampersand-model-namespaceattribute" class="section-sub-sub">namespaceAttribute <code>model.namespaceAttribute</code></a><a href="#ampersand-model-getnamespace" class="section-sub-sub">getNamespace <code>model.getNamespace()</code></a><a href="#ampersand-model-typeattribute" class="section-sub-sub">typeAttribute</a><a href="#ampersand-model-gettype" class="section-sub-sub">getType <code>model.getType()</code></a><a href="#ampersand-model-constructorinitialize" class="section-sub-sub">constructor/initialize <code>new ExtendedAmpersandModel([attrs], [options])</code></a><a href="#ampersand-model-collection" class="section-sub-sub">collection <code>model.collection</code></a><a href="#ampersand-model-cid" class="section-sub-sub">cid <code>model.cid</code></a><a href="#ampersand-model-save" class="section-sub-sub">save <code>model.save([attributes], [options])</code></a><a href="#ampersand-model-fetch" class="section-sub-sub">fetch <code>model.fetch([options])</code></a><a href="#ampersand-model-destroy" class="section-sub-sub">destroy <code>model.destroy([options])</code></a><a href="#ampersand-model-sync" class="section-sub-sub">sync <code>model.sync(method, model, [options])</code></a><a href="#ampersand-model-isnew" class="section-sub-sub">isNew <code>model.isNew()</code></a><a href="#ampersand-model-url" class="section-sub-sub">url <code>model.url</code> or <code>model.url()</code></a><a href="#ampersand-model-urlroot" class="section-sub-sub">urlRoot <code>model.urlRoot or model.urlRoot()</code></a><a href="#ampersand-model-escape" class="section-sub-sub">escape <code>model.escape()</code></a><a href="#ampersand-model-isvalid" class="section-sub-sub">isValid <code>model.isValid()</code></a><a href="#ampersand-collection" class="section-top">ampersand-collection</a><a href="#ampersand-collection-installation" class="section-sub">Installation</a><a href="#ampersand-collection-api-reference" class="section-sub">API Reference</a><a href="#ampersand-collection-extend" class="section-sub-sub">extend <code>AmpersandCollection.extend([attributes])</code></a><a href="#ampersand-collection-model" class="section-sub-sub">model <code>collection.model</code></a><a href="#ampersand-collection-constructorinitialize" class="section-sub-sub">constructor/initialize <code>new AmpersandCollection([models], [options])</code></a><a href="#ampersand-collection-mainindex-collectionmainindex" class="section-sub-sub">mainIndex `collection.mainIndex</a><a href="#ampersand-collection-indexes" class="section-sub-sub">indexes <code>collections.indexes</code></a><a href="#ampersand-collection-length" class="section-sub-sub">length <code>collection.length</code></a><a href="#ampersand-collection-iscollectioninstanceof" class="section-sub-sub">isCollection/instanceof <code>collection.isCollection</code></a><a href="#ampersand-collection-add" class="section-sub-sub">add <code>collection.add(modelOrObject, [options])</code></a><a href="#ampersand-collection-serialize" class="section-sub-sub">serialize <code>collection.serialize()</code></a><a href="#ampersand-collection-tojson" class="section-sub-sub">toJSON <code>collection.toJSON()</code></a><a href="#ampersand-collection-set" class="section-sub-sub">set <code>collection.set(models, [options])</code></a><a href="#ampersand-collection-get" class="section-sub-sub">get <code>collection.get(query, [indexName])</code></a><a href="#ampersand-collection-at" class="section-sub-sub">at <code>collection.at(index)</code></a><a href="#ampersand-collection-remove" class="section-sub-sub">remove <code>collection.remove(models, [options])</code></a><a href="#ampersand-collection-reset" class="section-sub-sub">reset <code>collection.reset(models, [options])</code></a><a href="#ampersand-collection-sort" class="section-sub-sub">sort <code>collection.sort([options])</code></a><a href="#ampersand-collection-models" class="section-sub-sub">models <code>collection.models</code></a><a href="#ampersand-collection-" class="section-sub-sub"><strong>proxied ES5 array methods (9)</strong></a><a href="#ampersand-rest-collection" class="section-top">ampersand-rest-collection</a><a href="#ampersand-rest-collection-install" class="section-sub">Install</a><a href="#ampersand-rest-collection-api-reference" class="section-sub">API Reference</a><a href="#ampersand-rest-collection-ajaxconfig" class="section-sub-sub">ajaxConfig <code>AmpersandRestCollection.extend({ ajaxConfig: function () { ... } })</code></a><a href="#ampersand-rest-collection-fetch" class="section-sub-sub">fetch <code>collection.fetch([options])</code></a><a href="#ampersand-rest-collection-create" class="section-sub-sub">create <code>collection.create(model, [options])</code></a><a href="#ampersand-rest-collection-sync" class="section-sub-sub">sync <code>model.sync(method, collection, [options])</code></a><a href="#ampersand-rest-collection-underscore-methods-42" class="section-sub-sub">underscore methods (42)</a><a href="#ampersand-view" class="section-top">ampersand-view</a><a href="#ampersand-view-install" class="section-sub">Install</a><a href="#ampersand-view-api-reference" class="section-sub">API Reference</a><a href="#ampersand-view-extend" class="section-sub-sub">extend <code>AmpersandView.extend([properties])</code></a><a href="#ampersand-view-template" class="section-sub-sub">template <code>AmpersandView.extend({ template: &quot;&lt;div&gt;&lt;input&gt;&lt;/div&gt;&quot; })</code></a><a href="#ampersand-view-autorender" class="section-sub-sub">autoRender <code>AmpersandView.extend({ autoRender: true })</code></a><a href="#ampersand-view-events" class="section-sub-sub">events <code>AmpersandView.extend({ events: { /* ...events hash... */ } })</code></a><a href="#ampersand-view-bindings" class="section-sub-sub">bindings</a><a href="#ampersand-view-el" class="section-sub-sub">el <code>view.el</code></a><a href="#ampersand-view-constructor" class="section-sub-sub">constructor <code>new AmpersandView([options])</code></a><a href="#ampersand-view-initialize" class="section-sub-sub">initialize <code>new AmpersandView([options])</code></a><a href="#ampersand-view-render" class="section-sub-sub">render <code>view.render()</code></a><a href="#ampersand-view-rendercollection" class="section-sub-sub">renderCollection <code>view.renderCollection(collection, ItemView, containerEl, [viewOptions])</code></a><a href="#ampersand-view-registersubview" class="section-sub-sub">registerSubview <code>view.registerSubview(viewInstance)</code></a><a href="#ampersand-view-rendersubview" class="section-sub-sub">renderSubview <code>view.renderSubview(viewInstance, containerEl)</code></a><a href="#ampersand-view-renderwithtemplate" class="section-sub-sub">renderWithTemplate <code>view.renderWithTemplate([context], [template])</code></a><a href="#ampersand-view-get" class="section-sub-sub">get <code>view.get(&#39;.classname&#39;)</code></a><a href="#ampersand-view-getbyrole" class="section-sub-sub">getByRole <code>view.getByRole(&#39;rolename&#39;)</code></a><a href="#ampersand-view-getall" class="section-sub-sub">getAll <code>view.getAll(&#39;.classname&#39;)</code></a><a href="#ampersand-view-cacheelements" class="section-sub-sub">cacheElements <code>view.cacheElements(hash)</code></a><a href="#ampersand-view-listentoandrun" class="section-sub-sub">listenToAndRun <code>view.listenToAndRun(object, eventsString, callback)</code></a><a href="#ampersand-view-remove" class="section-sub-sub">remove <code>view.remove()</code></a><a href="#ampersand-view-delegateevents" class="section-sub-sub">delegateEvents <code>view.delegateEvents([events])</code></a><a href="#ampersand-view-undelegateevents" class="section-sub-sub">undelegateEvents <code>view.undelegateEvents()</code></a><a href="#ampersand-view-switcher" class="section-top">ampersand-view-switcher</a><a href="#ampersand-view-switcher-install" class="section-sub">Install</a><a href="#ampersand-view-switcher-example" class="section-sub">Example</a><a href="#ampersand-view-switcher-api-reference" class="section-sub">API Reference</a><a href="#ampersand-view-switcher-constructor" class="section-sub-sub">constructor <code>new ViewSwitcher(element, [options])</code></a><a href="#ampersand-view-switcher-set" class="section-sub-sub">set <code>switcher.set(viewInstance)</code></a><a href="#ampersand-view-switcher-clear" class="section-sub-sub">clear <code>switcher.clear(callback)</code></a><a href="#ampersand-router" class="section-top">ampersand-router</a><a href="#ampersand-router-install" class="section-sub">install</a><a href="#ampersand-router-api-reference" class="section-sub">API Reference</a><a href="#ampersand-router-extend" class="section-sub-sub">extend <code>AmpersandRouter.extend(properties)</code></a><a href="#ampersand-router-routers" class="section-sub-sub">routers <code>router.routes</code></a><a href="#ampersand-router-constructor-initialize" class="section-sub-sub">constructor / initialize <code>new Router([options])</code></a><a href="#ampersand-router-route" class="section-sub-sub">route <code>router.route(route, name, [callback])</code></a><a href="#ampersand-router-navigate" class="section-sub-sub">navigate <code>router.navigate(fragment, [options])</code></a><a href="#ampersand-router-redirectto" class="section-sub-sub">redirectTo <code>router.redirectTo(fragment)</code></a><a href="#ampersand-router-execute" class="section-sub-sub">execute <code>router.execute(callback, args)</code></a><a href="#ampersand-router-historystart" class="section-sub-sub">history.start <code>router.history.start([options])</code></a>
      </nav>
      <div class="docs-content">
        <section><a name="intro" href="#intro" class="anchor">
            <h1><span class="header-link"></span>API Documentation</h1></a>
          <p>This page has consolidated API reference documentation for the core modules in a single page for the sake of being 'cmd+f' friendly.</p>
          <p>For more in-depth guides, conventions, best practices, and how to use these tools together please see <a href="/learn">guides</a>.</p>
        </section>
        <section class="module"><a name="ampersand" href="#ampersand" class="anchor">
            <h1><span class="header-link"></span>ampersand.js app scaffolding</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand</h4>
            <p class="module-version">latest v1.6.1</p>
            <p class="module-description">CLI tool for generating single page apps a. la. http://humanjavascript.com</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand">github</a><a href="https://www.npmjs.org/package/ampersand">npm</a></p>
          </div>
          <div><p>Install it, then follow the prompts to generate a starting point for your app.</p>
<pre><code>npm i ampersand -g &amp;&amp; ampersand
</code></pre><a name="ampersand-defaults" class="anchor" href="#ampersand-defaults"><h2><span class="header-link"></span>Defaults</h2></a><p>You can optionally create a <code>.ampersandjsrc</code> file in your home folder containing JSON with your preferred defaults.</p>
<p>Currently the only options are: </p>
<pre><code class="undefinedjson">{
    &quot;name&quot;: &quot;Your Name &lt;maybe_your_email@your_domain.com&gt;&quot;,
    &quot;framework&quot;: &quot;express || hapi&quot;
}
</code></pre>
<p>This config simply changes the suggested defaults when answering questions. They can still be overwritten when running the generator, but saves a bit of typing.</p>
</div>
        </section>
        <section class="module"><a name="ampersand-state" href="#ampersand-state" class="anchor">
            <h1><span class="header-link"></span>ampersand-state</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-state</h4>
            <p class="module-version">latest v4.2.7</p>
            <p class="module-description">An observable, extensible state object with derived watchable properties.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-state">github</a><a href="https://www.npmjs.org/package/ampersand-state">npm</a></p>
          </div>
          <div><p>An observable, extensible state object with derived watchable properties.</p>
<p>Ampersand-state serves as a base object for <a href="http://github.com/ampersandjs/ampersand-model">ampersand-model</a> but is useful any time you want to track complex state.</p>
<p><a href="https://github.com/ampersandjs/ampersand-model">ampersand-model</a> extends ampersand-state to include assumptions that you&#39;d want if you&#39;re using models to model date from a REST API. But by itself ampersand-state is useful for anytime you want something to model state, that fires events for changes and lets you define and listen to derived properties.</p>
<a name="ampersand-state-install" class="anchor" href="#ampersand-state-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-state --save
</code></pre><a name="ampersand-state-api-reference" class="anchor" href="#ampersand-state-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-state-extend" class="anchor" href="#ampersand-state-extend"><h3><span class="header-link"></span>extend <code>AmpersandState.extend({ })</code></h3></a><p>To create a <strong>State</strong> class of your own, you extend <strong>AmpersandState</strong> and provide instance properties an options for your class. Typically here you will pass any properties (<code>props</code>, <code>session</code> and <code>derived</code> of your state class, and any instance methods to be attached to instances of your class.</p>
<p><strong>extend</strong> correctly sets up the prototype chain, so that subclasses created with <strong>extend</strong> can be further extended as many times as you like.</p>
<p>Definitions like <code>props</code>, <code>session</code>, <code>derived</code> etc will be merged with superclass definitions.</p>
<pre><code class="undefinedjavascript">var Person = AmpersandState.extend({
    props: {
        firstName: &#39;string&#39;,
        lastName: &#39;string&#39;
    },
    session: {
        signedIn: [&#39;boolean&#39;, true, false],
    },
    derived: {
        fullName: {
            deps: [&#39;firstName&#39;, &#39;lastName&#39;],
            fn: function () {
                return this.firstName + &#39; &#39; + this.lastName;
            }
        }
    }
});
</code></pre>
<a name="ampersand-state-constructorinitialize" class="anchor" href="#ampersand-state-constructorinitialize"><h3><span class="header-link"></span>constructor/initialize <code>new AmpersandState([attrs], [options])</code></h3></a><p>When creating an instance of a state object, you can pass in the initial values of the <strong>attributes</strong> which will be <a href="#ampersand-state-set">set</a> on the model. Unless <a href="#amperand-state-extra-properties">extraProperties</a> is set to <code>allow</code>, you will need to have defined these attributes in <code>props</code> or <code>session</code>.</p>
<p>If you have defined an <strong>initialize</strong> function for your subclass of State, it will be invoked at creation time.</p>
<pre><code class="undefinedjavascript">var me = new Person({
    firstName: &#39;Phil&#39;
    lastName: &#39;Roberts&#39;
});

me.firstName //=&gt; Phil
</code></pre>
<p>Available options:</p>
<ul>
<li><code>[parse]</code> {Boolean} - whether to call the class&#39;s <a href="#ampersand-state-parse">parse</a> function with the initial attributes. <em>Defaults to <code>false</code></em>.</li>
<li><code>[parent]</code> {AmpersandState} - pass a reference to a model&#39;s parent to store on the model.</li>
</ul>
<a name="ampersand-state-extraproperties" class="anchor" href="#ampersand-state-extraproperties"><h3><span class="header-link"></span>extraProperties <code>AmpersandState.extend({ extraProperties: &#39;allow&#39; })</code></h3></a><p>Defines how properties that aren&#39;t defined in <code>props</code>, <code>session</code> or <code>derived</code> are handled. May be set to <code>&#39;allow&#39;</code>, <code>&#39;reject&#39;</code> or <code>&#39;allow&#39;</code>.</p>
<pre><code class="undefinedjavascript">var StateA = AmpersandState.extend({
    extraProperties: &#39;allow&#39;,
});

var stateA = new StateA({ foo: &#39;bar&#39; });
stateA.foo === &#39;bar&#39; //=&gt; true


var StateB = AmpersandState.extend({
    extraProperties: &#39;ignore&#39;,
});

var stateB = new StateB({ foo: &#39;bar&#39; });
stateB.foo === undefined //=&gt; true


var stateC = AmpersandState.extend({
    extraProperties: &#39;reject&#39;
});

var stateC = new StateC({ foo: &#39;bar&#39; })
//=&gt; TypeError(&#39;No foo property defined on this model and extraProperties not set to &quot;ignore&quot; or &quot;allow&quot;.&#39;);
</code></pre>
<a name="ampersand-state-datatypes" class="anchor" href="#ampersand-state-datatypes"><h3><span class="header-link"></span>dataTypes</h3></a><a name="ampersand-state-props" class="anchor" href="#ampersand-state-props"><h3><span class="header-link"></span>props <code>AmpersandView.extend({ props: { name: &#39;string&#39; } })</code></h3></a><p>Pass <strong>props</strong> as an object to extend, describing the observable properties of your state class. The props properties should not be set on an instance, as this won&#39;t define new properties, they should only be passed to extend.</p>
<p>Properties can be defined in three different ways:</p>
<ul>
<li>As a string with the expected dataType. One of <code>string</code>, <code>number</code>, <code>boolean</code>, <code>array</code>, <code>object</code>, <code>date</code>, or <code>any</code>. Eg: <code>name: &#39;string&#39;</code>. Can also be set to the name of a custom <code>dataTypes</code> if any are defined for the class.</li>
<li>An array of <code>[dataType, required, default]</code></li>
<li><p>An object <code>{ type: &#39;string&#39;, required: true, default: &#39;&#39; , allowNull: false}</code></p>
</li>
<li><p>If <code>required</code> is true, and a <code>default</code> is set for the property, the property will start with that value, and revert to it after a call to <code>unset(propertyName)</code>.</p>
</li>
<li>Trying to set a property to an invalid type will raise an exception.</li>
<li>See <a href="#ampersand-state-get">get</a> and <a href="#ampersand-state-set">set</a> for more information about getting and setting properties.</li>
</ul>
<pre><code class="undefinedjavascript">var Person = AmpersandState.extend({
    props: {
        name: &#39;string&#39;,
        age: &#39;number&#39;,
        paying: [&#39;boolean&#39;, true, false], //required attribute, defaulted to false
        type: {
            type: &#39;string&#39;,
            values: [&#39;regular-hero&#39;, &#39;super-hero&#39;, &#39;mega-hero&#39;
        }
    }
});
</code></pre>
<a name="ampersand-state-session" class="anchor" href="#ampersand-state-session"><h3><span class="header-link"></span>session <code>AmpersandView.extend({ session: { name: &#39;string&#39; } })</code></h3></a><p>Session properties are defined and work in exactly the same way as <a href="#ampersand-state-props">props</a>, but generally only exist for the lifetime of the page. They would not typically be persisted to the server, and are not returned by calls to <code>toJSON()</code> or <code>serialize()</code>.</p>
<pre><code class="undefinedjavascript">var Person = AmpersandState.extend({
    props: {
        name: &#39;string&#39;,
    },
    session: {
        isLoggedIn: &#39;boolean&#39;
    }
);
</code></pre>
<a name="ampersand-state-derived" class="anchor" href="#ampersand-state-derived"><h3><span class="header-link"></span>derived</h3></a><p>Derived properties (also known as computed properties) are properties of the state object that depend on the other (<code>props</code>, <code>session</code>  or even <code>derived</code> properties to determine their value. Best demonstrated with an example:</p>
<pre><code class="undefinedjavascript">var Person = AmpersandState.extend({
    props: {
        firstName: &#39;string&#39;,
        lastName: &#39;string&#39;
    },
    derived: {
        fullName: {
            deps: [&#39;firstName&#39;, &#39;lastName&#39;],
            fn: function () {
                return this.firstName + &#39; &#39; + this.lastName;
            }
        }
    }
});

var person = new Person({ firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39; });
console.log(person.fullName) //=&gt; &quot;Phil Roberts&quot;

person.firstName = &#39;Bob&#39;;
console.log(person.fullName) //=&gt; &quot;Bob Roberts&quot;
</code></pre>
<p>Each derived property, is defined as an object with the current properties:</p>
<ul>
<li><code>deps</code> {Array} - An array of property names which the derived property depends on.</li>
<li><code>fn</code> {Function} - A function which returns the value of the computed property. It is called in the context of the current object, so that <code>this</code> is set correctly.</li>
<li><code>cache</code> {Boolean} - Whether to cache the property. Uncached properties are computed everytime they are accessed. Useful if it depends on the current time for example. <em>Defaults to <code>true</code></em>.</li>
</ul>
<p>Derived properties are retrieved and fire change events just like any other property. They cannot be set directly. Caching ensures that the <code>fn</code> function is only run when any of the dependencies change, and change events are only fired if the result of calling <code>fn()</code> has actually changed.</p>
<a name="ampersand-state-children" class="anchor" href="#ampersand-state-children"><h3><span class="header-link"></span>children <code>AmpersandState.extend({ children: { profile: Profile } })</code></h3></a><p>Define child state objects to attach to the object. Attributes passed to the constructor or to <code>set()</code> will be proxied to the children/collections. Change events on the child will be proxied through the parent:</p>
<pre><code class="undefinedjavascript">var AmpersandState = require(&#39;ampersand-state&#39;);
var Hat = AmpersandState.extend({
    props: {
        color: &#39;string&#39;
    }
});

var Person = AmpersandState.extend({
    props: {
        name: &#39;Phil&#39;
    },
    children: {
        hat: Hat
    }
});

var me = new Person({ name: &#39;Phil&#39;, hat: { color: &#39;red&#39; } });

me.on(&#39;all&#39;, function (eventName) {
    console.log(&#39;Got event: &#39;, eventName);
});

console.log(me.hat) //=&gt; Hat{color: &#39;red&#39;}

me.set({ hat: { color: &#39;green&#39; } });
//-&gt; &quot;Got event: change:hat.color&quot;
//-&gt; &quot;Got event: change&quot;

console.log(me.hat) //=&gt; Hat{color: &#39;green&#39;}
</code></pre>
<a name="ampersand-state-parse" class="anchor" href="#ampersand-state-parse"><h3><span class="header-link"></span>parse</h3></a><p><strong>parse</strong> is called when the model is initialized allowing the attributes to be modified/remapped/renamed/etc before they are actually applied to the model. In ampersand-state, parse is only called when the model is first initialized, and only if <code>{ parse: true }</code> is passed to the constructor options:</p>
<pre><code class="undefinedjavascript">var Person = AmpersandState.extend({
    props: {
        id: &#39;number&#39;,
        name: &#39;string&#39;
    },

    parse: function (attrs) {
        attrs.id = attrs.personID; //remap an oddly named attribute
        delete attrs.personID;

        return attrs;
    }
});

var me = new Person({ personID: 123, name: &#39;Phil&#39; });

console.log(me.id) //=&gt; 123
console.log(me.personID) //=&gt; undefined
</code></pre>
<p><strong>parse</strong> is arguably more useful in ampersand-model, where data typically comes from the server.</p>
<a name="ampersand-state-serialize" class="anchor" href="#ampersand-state-serialize"><h3><span class="header-link"></span>serialize <code>state.serialize()</code></h3></a><p>Serialize the state object into a plain object, ready for sending to the server (typically called via <a href="#ampersand-state-tojson">toJSON</a>). Of the model&#39;s properties, only <code>props</code> is returned, <code>session</code> and <code>derived</code> are omitted. Will also serialize any <code>children</code> or <code>collections</code> by calling their serialize methods.</p>
<a name="ampersand-state-get" class="anchor" href="#ampersand-state-get"><h3><span class="header-link"></span>get <code>state.get(attribute); state[attribute]; state.firstName</code></h3></a><p>Get the current value of an attribute from the state object. Attributes can be accessed directly, or a call to the Backbone style <code>get</code>. So these are all equivalent:</p>
<pre><code class="undefinedjavascript">person.get(&#39;firstName&#39;);
person[&#39;firstName&#39;];
person.firstName
</code></pre>
<p>Get will retrieve <code>props</code>, <code>session</code> or <code>derived</code> properties all in the same way.</p>
<a name="ampersand-state-set" class="anchor" href="#ampersand-state-set"><h3><span class="header-link"></span>set <code>state.set(attributes, [options]); state.firstName = &#39;Henrik&#39;;</code></h3></a><p>Set an attribute, or multiple attributes, on the state object. If any of the attributes change the state of the object, a <code>&quot;change&quot;</code> event will be triggered on it. Change events for specific attributes are also triggered, which you can listen to as well. For example: <code>&quot;change:firstName&quot;</code> and <code>&quot;change:content&quot;</code>. If the changes update any <code>derived</code> properties on the object, their values will be updated, and change events fired as well.</p>
<p>Attributes can be set directly, or via a call to the backbone style <code>set</code> (useful if you wish to update multiple attributes at once):</p>
<pre><code class="undefinedjavascript">person.set({firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39;});
person.set(&#39;firstName&#39;, &#39;Phil&#39;);
person.firstName = &#39;Phil&#39;;
</code></pre>
<p>Possible options (when using <code>state.set()</code>):</p>
<ul>
<li><code>silent</code> {Boolean} - prevents triggering of any change events as a result of the set operation.</li>
<li><code>unset</code> {Boolean} - <code>unset</code> the attributes keyed in the attributes object instead of setting them.</li>
</ul>
<a name="ampersand-state-unset" class="anchor" href="#ampersand-state-unset"><h3><span class="header-link"></span>unset <code>state.unset(attribute, [options])</code></h3></a><p>Clear the named attribute from the state object. Fires a <code>&quot;change&quot;</code> event and a <code>&quot;change:attributeName&quot;</code> event unless <code>silent</code> is passed as an option.</p>
<p>If the attribute being unset is <code>required</code> and has a <code>default</code> value as defined in either <code>props</code> or <code>session</code>, it will be set to that value, otherwise it will be <code>undefined</code>.</p>
<pre><code class="undefinedjavascript">person.unset(&#39;firstName&#39;)
</code></pre>
<a name="ampersand-state-toggle" class="anchor" href="#ampersand-state-toggle"><h3><span class="header-link"></span>toggle <code>state.toggle(&#39;active&#39;)</code></h3></a><p>Shortcut to toggle boolean properties, or cycle through &quot;ENUM&quot; type properties that have a <code>values</code> array in it&#39;s definition. Fires change events as you would expect from set.</p>
<pre><code class="undefinedjavascript">var Person = AmpersandState.extend({
    props: {
        active: &#39;boolean&#39;,
        color: {
            type: &#39;string&#39;,
            values: [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
        }
    }
});

var me = new Person({ active: true, color: &#39;green&#39; });

me.toggle(&#39;active&#39;);
console.log(me.active) //=&gt; false

me.toggle(&#39;color&#39;);
console.log(me.color) //=&gt; &#39;blue&#39;

me.toggle(&#39;color&#39;);
console.log(me.color) //=&gt; &#39;red&#39;
</code></pre>
<a name="ampersand-state-previousattributes" class="anchor" href="#ampersand-state-previousattributes"><h3><span class="header-link"></span>previousAttributes <code>state.previousAttributes()</code></h3></a><p>Return a copy of the object&#39;s previous attributes (the state before the last <code>&quot;change&quot;</code> event). Useful for getting a diff between versions of a model, or getting back to a valid state after an error occurs.</p>
<a name="ampersand-state-haschanged" class="anchor" href="#ampersand-state-haschanged"><h3><span class="header-link"></span>hasChanged <code>state.hasChanged([attribute])</code></h3></a><p>Determine if the model has been modified since the last <code>&quot;change&quot;</code> event. If an attribute name is passed, determine if that one attribute has changed.</p>
<a name="ampersand-state-changedattributes" class="anchor" href="#ampersand-state-changedattributes"><h3><span class="header-link"></span>changedAttributes <code>state.changedAttributes([objectToDiff])</code></h3></a><p>Return an object containing all the attributes that have changed, or false if there are no changed attributes. Useful for determining what parts of a view need to be updated and/or what attributes need to be persisted to the server. Unset attributes will be set to undefined.  You can also pass an attributes object to diff against the model, determining if there <em>would be</em> a change.</p>
<a name="ampersand-state-tojson" class="anchor" href="#ampersand-state-tojson"><h3><span class="header-link"></span>toJSON <code>state.toJSON()</code></h3></a><p>Return a shallow copy of the model&#39;s attributes for JSON stringification. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn&#39;t actually return a JSON string — but I&#39;m afraid that it&#39;s the way that the JavaScript API for JSON.stringify works.</p>
<p>Calls <a href="#ampersand-state-serialize">serialize</a> to determine which values to return in the object. Will be called implicitly by JSON.stringify.</p>
<pre><code class="undefinedjavascript">var me = new Person({ firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39; });

me.toJSON() //=&gt; { firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39; }

//JSON.stringify implicitly calls toJSON:
JSON.stringify(me) //=&gt; &quot;{\&quot;firstName\&quot;:\&quot;Phil\&quot;,\&quot;lastName\&quot;:\&quot;Roberts\&quot;}&quot;
</code></pre>
</div>
        </section>
        <section class="module"><a name="ampersand-model" href="#ampersand-model" class="anchor">
            <h1><span class="header-link"></span>ampersand-model</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-model</h4>
            <p class="module-version">latest v3.0.1</p>
            <p class="module-description">An extension to ampersand-state that adds methods and properties for working with a RESTful API.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-model">github</a><a href="https://www.npmjs.org/package/ampersand-model">npm</a></p>
          </div>
          <div><p>ampersand-model is an extension built on <a href="http://ampersandjs.com/docs/#ampersand-state">ampersand-state</a> to provide methods and properties that you&#39;ll often want when modeling data you get from an API.</p>
<p>For further explanation see the <a href="http://ampersandjs.com/learn/state">learn ampersand-state</a> guide.</p>
<a name="ampersand-model-installing" class="anchor" href="#ampersand-model-installing"><h2><span class="header-link"></span>Installing</h2></a><pre><code>npm install ampersand-model
</code></pre><a name="ampersand-model-observing" class="anchor" href="#ampersand-model-observing"><h2><span class="header-link"></span>Observing</h2></a><p>Ampersand gets its event system from Backbone using the <a href="https://www.npmjs.org/package/backbone-events-standalone">backbone-events-standalone</a> module on npm.</p>
<p>For more, <a href="http://ampersandjs.com/learn/events">read all about how events work in ampersand</a>.</p>
<a name="ampersand-model-api-reference" class="anchor" href="#ampersand-model-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><p>The module exports just one item, the ampersand-model constructor. It&#39;s has a method called <code>extend</code> that works as follows:</p>
<a name="ampersand-model-extend" class="anchor" href="#ampersand-model-extend"><h3><span class="header-link"></span>extend <code>AmpersandModel.extend({ })</code></h3></a><p>To create a <strong>Model</strong> class of your own, you extend <strong>AmpersandModel</strong> and provide instance properties and options for your class. Typically here you will pass any properties (<code>props</code>, <code>session</code>, and <code>derived</code>) of your model class, and any instance methods to be attached to instances of your class.</p>
<p><strong>extend</strong> correctly sets up the prototype chain, so that subclasses created with <strong>extend</strong> can be further extended as many times as you like.</p>
<p>As with AmpersandState, definitions like <code>props</code>, <code>session</code>, <code>derived</code> etc will be merged with superclass definitions.</p>
<pre><code class="undefinedjavascript">var Person = AmpersandModel.extend({
    props: {
        firstName: &#39;string&#39;,
        lastName: &#39;string&#39;
    },
    session: {
        signedIn: [&#39;boolean&#39;, true, false],
    },
    derived: {
        fullName: {
            deps: [&#39;firstName&#39;, &#39;lastName&#39;],
            fn: function () {
                return this.firstName + &#39; &#39; + this.lastName;
            }
        }
    }
});
</code></pre>
<a name="ampersand-model-idattribute" class="anchor" href="#ampersand-model-idattribute"><h3><span class="header-link"></span>idAttribute <code>model.idAttribute</code></h3></a><p>The attribute that should be used as the unique id of the model - typically the name of the property representing the model&#39;s id on the server. <code>getId</code> uses this to determine the id for use when constructing a model&#39;s url for saving to the server.</p>
<p>Defaults to <code>&#39;id&#39;</code>.</p>
<pre><code>var Person = AmpersandModel.extend({
    idAttribute: &#39;personId&#39;,
    urlRoot: &#39;/people&#39;,
    props: {
        personId: &#39;number&#39;,
        name: &#39;string&#39;
    }
});

var me = new Person({ personId: 123 });

console.log(me.url()) //=&gt; &quot;/people/123&quot;
</code></pre><a name="ampersand-model-getid" class="anchor" href="#ampersand-model-getid"><h3><span class="header-link"></span>getId <code>model.getId()</code></h3></a><p>Get ID of model per <code>idAttribute</code> configuration. Should <em>always</em> be how ID is determined by other code.</p>
<a name="ampersand-model-namespaceattribute" class="anchor" href="#ampersand-model-namespaceattribute"><h3><span class="header-link"></span>namespaceAttribute <code>model.namespaceAttribute</code></h3></a><p>The property name that should be used as a namespace. Namespaces are completely optional, but exist in case you need to make an additionl distinction between models, that may be of the same type, with potentially conflicting IDs but are in fact different.</p>
<p>Defaults to <code>&#39;namespace&#39;</code>.</p>
<a name="ampersand-model-getnamespace" class="anchor" href="#ampersand-model-getnamespace"><h3><span class="header-link"></span>getNamespace <code>model.getNamespace()</code></h3></a><p>Get namespace of model per <code>namespaceAttribute</code> configuration. Should <em>always</em> be how namespace is determined by other code.</p>
<a name="ampersand-model-typeattribute" class="anchor" href="#ampersand-model-typeattribute"><h3><span class="header-link"></span>typeAttribute</h3></a><p>The property name that should be used to specify what type of model this is. This is optional, but specifying a model type types provides a standard, yet configurable way to determine what type of model it is.</p>
<p>Defaults to <code>&#39;modelType&#39;</code>.</p>
<a name="ampersand-model-gettype" class="anchor" href="#ampersand-model-gettype"><h3><span class="header-link"></span>getType <code>model.getType()</code></h3></a><p>Get type of model per <code>typeAttribute</code> configuration. Should <em>always</em> be how type is determined by other code.</p>
<a name="ampersand-model-constructorinitialize" class="anchor" href="#ampersand-model-constructorinitialize"><h3><span class="header-link"></span>constructor/initialize <code>new ExtendedAmpersandModel([attrs], [options])</code></h3></a><p>This works exactly like <a href="http://ampersandjs.com/docs/#ampersand-state-constructorinitialize">state</a> with a minor addition: If you pass <code>collection</code> as part of options it&#39;ll be stored for reference.</p>
<p>As with AmpersandState, if you have defined an <strong>initialize</strong> function for your subclass of State, it will be invoked at creation time.</p>
<pre><code class="undefinedjavascript">var me = new Person({
    firstName: &#39;Phil&#39;
    lastName: &#39;Roberts&#39;
});

me.firstName //=&gt; Phil
</code></pre>
<p>Available options:</p>
<ul>
<li><code>[parse]</code> {Boolean} - whether to call the class&#39;s <a href="#ampersand-state-parse">parse</a> function with the initial attributes. <em>Defaults to <code>false</code></em>.</li>
<li><code>[parent]</code> {AmpersandState} - pass a reference to a model&#39;s parent to store on the model.</li>
<li><code>[collection]</code> {Collection} - pass a reference to the collection the model is in. Defaults to <code>undefined</code>.</li>
</ul>
<a name="ampersand-model-collection" class="anchor" href="#ampersand-model-collection"><h3><span class="header-link"></span>collection <code>model.collection</code></h3></a><p>A reference to the collection a model is in, if in a collection.</p>
<p>This is used for building the default <code>url</code> property, etc. </p>
<p>Which is why you can do this:</p>
<pre><code class="undefinedjs">// some ampersand-rest-collection instance
// with a `url` property
widgets.url //=&gt; &#39;/api/widgets&#39;

// get a widget from our collection
var badWidget = widgets.get(&#39;47&#39;);

// Without a `collection` reference this
// widget wouldn&#39;t know what URL to build
// when calling destroy
badWidget.destroy(); // does a DELETE /api/widgets/47
</code></pre>
<a name="ampersand-model-cid" class="anchor" href="#ampersand-model-cid"><h3><span class="header-link"></span>cid <code>model.cid</code></h3></a><p>A special property of models, the <strong>cid</strong>, or a client id, is a unique identifier automatically assigned to all models when they are first created. Client ids are handy when the model has not been saved to the server, and so does not yet have it&#39;s true <strong>id</strong> but needs a unique id so it can be rendered in the UI etc.</p>
<pre><code class="undefinedjavascript">var userA = new User();
console.log(userA.cid) //=&gt; &quot;model-1&quot;

var userB = new User();
console.log(userB.cid) //=&gt; &quot;model-2&quot;
</code></pre>
<a name="ampersand-model-save" class="anchor" href="#ampersand-model-save"><h3><span class="header-link"></span>save <code>model.save([attributes], [options])</code></h3></a><p>Save a model to your database (or alternative persistence layer), by delegating to <a href="https://github.com/ampersandjs/ampersand-sync">ampersand-sync</a>. Returns a xhr object if validation is successful and false otherwise. The attributes hash (as in set) should contain the attributes you&#39;d like to change — keys that aren&#39;t mentioned won&#39;t be altered — but, a <em>complete representation</em> of the resource will be sent to the server. As with <code>set</code>, you may pass individual keys and values instead of a hash. If the model has a validate method, and validation fails, the model will not be saved. If the model <code>isNew</code>, the save will be a &quot;create&quot; (HTTP POST), if the model already exists on the server, the save will be an &quot;update&quot; (HTTP PUT).</p>
<p>If instead, you&#39;d only like the changed attributes to be sent to the server, call <code>model.save(attrs, {patch: true})</code>. You&#39;ll get an HTTP PATCH request to the server with just the passed-in attributes.</p>
<p>Calling save with new attributes will cause a <code>&quot;change&quot;</code> event immediately, a <code>&quot;request&quot;</code> event as the Ajax request begins to go to the server, and a <code>&quot;sync&quot;</code> event after the server has acknowledged the successful change. Pass <code>{wait: true}</code> if you&#39;d like to wait for the server before setting the new attributes on the model.</p>
<pre><code class="undefinedjavascript">var book = new Backbone.Model({
  title: &quot;The Rough Riders&quot;,
  author: &quot;Theodore Roosevelt&quot;
});

book.save();
//=&gt; triggers a `POST` via ampersand-sync with { &quot;title&quot;: &quot;The Rough Riders&quot;, &quot;author&quot;: &quot;Theodore Roosevelt&quot; }

book.save({author: &quot;Teddy&quot;});
//=&gt; triggers a `PUT` via ampersand-sync with { &quot;title&quot;: &quot;The Rough Riders&quot;, &quot;author&quot;: &quot;Teddy&quot; }
</code></pre>
<p><strong>save</strong> accepts <code>success</code> and <code>error</code> callbacks in the options hash, which will be passed the arguments <code>(model, response, options)</code>. If a server-side validation fails, return a non-<code>200</code> HTTP response code, along with an error response in text or JSON.</p>
<a name="ampersand-model-fetch" class="anchor" href="#ampersand-model-fetch"><h3><span class="header-link"></span>fetch <code>model.fetch([options])</code></h3></a><p>Resets the model&#39;s state from the server by delegating to ampersand-sync. Returns a xhr. Useful if the model has yet to be populated with data, or you want to ensure you have the latest server state. A <code>&quot;change&quot;</code> event will be triggered if the retrieved state from the server differs from the current attributes. Accepts <code>success</code> and <code>error</code> callbacks in the options hash, which are both passed <code>(model, response, options)</code> as arguments.</p>
<pre><code class="undefinedjavascript">var me = new Person({id: 123});
me.fetch();
</code></pre>
<a name="ampersand-model-destroy" class="anchor" href="#ampersand-model-destroy"><h3><span class="header-link"></span>destroy <code>model.destroy([options])</code></h3></a><p>Destroys the model on the server by delegating an HTTP <code>DELETE</code> request to ampersand-sync. Returns the xhr object, or <code>false</code> if the model <a href="#ampersand-model-isnew">isNew</a>. Accepts <code>success</code> and <code>error</code> callbacks in the options hash, which are both passed <code>(model, response, options)</code> as arguments.</p>
<p>Triggers:</p>
<ul>
<li>a <code>&quot;destroy&quot;</code> event on the model, which will bubble up through any collections which contain it.</li>
<li>a <code>&quot;request&quot;</code> event as it begins the Ajax request to the server</li>
<li>a <code>&quot;sync&quot;</code> event, after the server has successfully acknowledged the model&#39;s deletion.</li>
</ul>
<p>Pass <code>{wait: true}</code> if you&#39;d like to wait for the server to respond before removing the model from the collection.</p>
<pre><code class="undefinedjavascript">var task = new Task({ id: 123 });
task.destroy({
    success: function () { alert(&#39;Task destroyed!&#39;); },
    error: function () { alert(&#39;There was an error destroying the task&#39;); },
});
</code></pre>
<a name="ampersand-model-sync" class="anchor" href="#ampersand-model-sync"><h3><span class="header-link"></span>sync <code>model.sync(method, model, [options])</code></h3></a><p>Uses ampersand-sync to persist the state of a model to the server. Usually you won&#39;t call this directly, you&#39;d use <code>save</code> or <code>destroy</code> instead, but it can be overriden for custom behaviour.</p>
<a name="ampersand-model-isnew" class="anchor" href="#ampersand-model-isnew"><h3><span class="header-link"></span>isNew <code>model.isNew()</code></h3></a><p>Has this model been saved to the server yet? If the model does not yet have an id (using <code>getId()</code>), it is considered to be new.</p>
<a name="ampersand-model-url" class="anchor" href="#ampersand-model-url"><h3><span class="header-link"></span>url <code>model.url</code> or <code>model.url()</code></h3></a><p>The relative url the model should use to edit the resource on the server. </p>
<a name="ampersand-model-urlroot" class="anchor" href="#ampersand-model-urlroot"><h3><span class="header-link"></span>urlRoot <code>model.urlRoot or model.urlRoot()</code></h3></a><p>The base url to use for fetching this model. This is useful if the model is <em>not</em> in a collection and you still want to set a fixed &quot;root&quot; but have a dynamic model.url(). Can also be a function.</p>
<p>If your model is in a collection that has a <code>url</code> you won&#39;t need this, because the model will try to build the URL from its collection.</p>
<pre><code class="undefinedjs">var Person = AmpersandModel.extend({
    props: {
        id: &#39;string&#39;,
        name: &#39;string&#39;
    },
    urlRoot: &#39;/api/persons&#39;
});

var bob = new Person({id: &quot;1234&quot;});

console.log(bob.url()); //=&gt; &quot;/api/persons/1234&quot;
</code></pre>
<a name="ampersand-model-escape" class="anchor" href="#ampersand-model-escape"><h3><span class="header-link"></span>escape <code>model.escape()</code></h3></a><p>Similar to <code>get</code>, but returns the HTML-escaped version of a model&#39;s attribute. If you&#39;re interpolating data from the model into HTML, using <strong>escape</strong> to retrieve attributes will help prevent XSS attacks.</p>
<pre><code>var hacker = new PersonModel({
    name: &quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;
});

document.body.innerHTML = hacker.escape(&#39;name&#39;);
</code></pre><a name="ampersand-model-isvalid" class="anchor" href="#ampersand-model-isvalid"><h3><span class="header-link"></span>isValid <code>model.isValid()</code></h3></a><p>Check if the model is currently in a valid state, it does this by calling the <code>validate</code> method, of your model if you&#39;ve provided one.</p>
</div>
        </section>
        <section class="module"><a name="ampersand-collection" href="#ampersand-collection" class="anchor">
            <h1><span class="header-link"></span>ampersand-collection</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-collection</h4>
            <p class="module-version">latest v1.3.6</p>
            <p class="module-description">A way to store/manage objects or models.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-collection">github</a><a href="https://www.npmjs.org/package/ampersand-collection">npm</a></p>
          </div>
          <div><p>A way to store/manage objects or models.</p>
<p>Unlike other tools this makes no assumptions about how it&#39;s going to be used or what type of models it is going to contain. This makes it a very flexible/useful tool for modeling all kinds of stuff.</p>
<p>It does not require underscore or jQuery, but instead makes it easy to extend with those methods if you&#39;d like.</p>
<a name="ampersand-collection-installation" class="anchor" href="#ampersand-collection-installation"><h2><span class="header-link"></span>Installation</h2></a><pre><code>npm i ampersand-collection
</code></pre><a name="ampersand-collection-api-reference" class="anchor" href="#ampersand-collection-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-collection-extend" class="anchor" href="#ampersand-collection-extend"><h3><span class="header-link"></span>extend <code>AmpersandCollection.extend([attributes])</code></h3></a><p>Create a collection class of your own by extending AmpersandCollection, providing the required instance properties to be attached instances of your class.</p>
<p>Typically you will specify a <code>model</code> constructor (if you are storing <a href="#ampersand-state">ampersand-state</a> or <a href="#ampersand-model">ampersand-model</a> objects.</p>
<a name="ampersand-collection-model" class="anchor" href="#ampersand-collection-model"><h3><span class="header-link"></span>model <code>collection.model</code></h3></a><p>Override this property to specify the model class that the collection contains. If defined, you can pass raw attributes objects (and arrays) to <code>add</code> and <code>reset</code>, and the attributes will be converted into a model of the proper type.</p>
<pre><code class="undefinedjavascript">var Library = AmeprsandCollection.extend({
    model: Book
});
</code></pre>
<p>A collection can also contain polymorphic models by overriding this property with a function that returns a model.</p>
<pre><code class="undefinedjavascript">var Library = Backbone.Collection.extend({

  model: function(attrs, options) {
    if (condition) {
      return new PublicDocument(attrs, options);
    } else {
      return new PrivateDocument(attrs, options);
    }
  }

});
</code></pre>
<a name="ampersand-collection-constructorinitialize" class="anchor" href="#ampersand-collection-constructorinitialize"><h3><span class="header-link"></span>constructor/initialize <code>new AmpersandCollection([models], [options])</code></h3></a><p>When creating an AmpersandCollection, you may choose to pass in the initial array of <strong>models</strong>. The collection&#39;s <a href="#ampersand-collection-compator">comparator</a> may be included as an option. Passing <code>false</code> as the comparator option will prevent sorting. If you define an <strong>initialize</strong> function, it will be invoked when the collection is created. There are a couple of options that, if provided, are attached to the collection directly: <code>model</code> and <code>comparator</code>.</p>
<pre><code class="undefinedjavascript">var people = new AmpersandCollection([{ name: &#39;phil&#39; }, { name: &#39;bob&#39; }, { name: &#39;jane&#39; }], {
    model: Person
});
</code></pre>
<a name="ampersand-collection-mainindex-collectionmainindex" class="anchor" href="#ampersand-collection-mainindex-collectionmainindex"><h3><span class="header-link"></span>mainIndex `collection.mainIndex</h3></a><p>Specify which key on your models should be used as their main unique identifier. Defaults to <code>id</code>. This is the default key that <a href="#ampersand-collection-get"><code>get</code></a> will use to retrieve models by, as well as the key add/set/remove will compare to determine whether a model exists in the collection or not.</p>
<p>If your server does not use <code>id</code> as the model identifier, you would typically override this when extending AmpersandCollection, like so:</p>
<pre><code class="undefinedjavascript">var People = AmpersandColletion.extend({
    mainIndex: &#39;_id&#39;
});
</code></pre>
<a name="ampersand-collection-indexes" class="anchor" href="#ampersand-collection-indexes"><h3><span class="header-link"></span>indexes <code>collections.indexes</code></h3></a><p>Specify an optional array of keys by which to additionally index the models in your collection (in addition to the <code>mainIndex</code>. This allows you to quickly retrieve models by specifying the key to use with <a href="#ampersand-collection-get">get</a>.</p>
<p>Note that <code>get</code> will only ever return a single model, so the values of these indexes should be unique across the models in the collection:</p>
<pre><code class="undefinedjavascript">var People = AmpersandCollection.extend({
    mainIndex: &#39;_id&#39;,

    indexes: [&#39;otherId&#39;]
});

var people = new People.add([
    { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; },
    { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
    { _id: 3, otherId: &#39;c&#39;, name: &#39;Henrik&#39; },
    { _id: 4, otherId: &#39;d&#39;, name: &#39;Jenn&#39; }
]);

people.get(1) //=&gt; { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; }

people.get(&#39;b&#39;, &#39;otherId&#39;) //=&gt; { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
</code></pre>
<a name="ampersand-collection-length" class="anchor" href="#ampersand-collection-length"><h3><span class="header-link"></span>length <code>collection.length</code></h3></a><p>Returns the length of the underlying array.</p>
<a name="ampersand-collection-iscollectioninstanceof" class="anchor" href="#ampersand-collection-iscollectioninstanceof"><h3><span class="header-link"></span>isCollection/instanceof <code>collection.isCollection</code></h3></a><p>With npm and browserify for module deps you can sometimes end up with a situation where, the same <code>collection</code> constructor wasn&#39;t  used to build a <code>collection</code> object. As a result <code>instanceof</code> checks will fail.</p>
<p>In order to deal with this (because sometimes this is a legitimate scenario), <code>collection</code> simply creates a read-only <code>isCollection</code> property on all collection objects that can be used to check whether or a not a given object is in fact a collection object no matter what its constructor was.</p>
<a name="ampersand-collection-add" class="anchor" href="#ampersand-collection-add"><h3><span class="header-link"></span>add <code>collection.add(modelOrObject, [options])</code></h3></a><p>Add a model (or an array of models) to the collection, firing an <code>&quot;add&quot;</code> event. If a <a href="#ampersand-collection-model">model</a> property is defined, you may also pass raw attributes objects, and have them be vivified as instances of the model. Returns the added (or preexisting, if duplicate) models.</p>
<p><strong>Options:</strong></p>
<ul>
<li>Pass <code>{at: index}</code> to splice the model into the collection at the specified index.</li>
<li>If you&#39;re adding models to the collection that are already in the collection, they&#39;ll be ignored, unless you pass <code>{merge: true}</code>, in which case their attributes will be merged into the corresponding models, firing any appropriate <code>&quot;change&quot;</code> events.</li>
</ul>
<pre><code class="undefinedjavascript">var ships = new AmpersandCollection();

ships.on(&quot;add&quot;, function(ship) {
  console.lg(&quot;Ahoy &quot; + ship.name + &quot;!&quot;);
});

ships.add([
  {name: &quot;Flying Dutchman&quot;},
  {name: &quot;Black Pearl&quot;}
]);

//logs:
//- &quot;Ahoy Flying Dutchman!&quot;
//- &quot;Ahoy Black Pearl!&quot;
</code></pre>
<p>Note that adding the same model (a model with the same id) to a collection more than once is a no-op.</p>
<a name="ampersand-collection-serialize" class="anchor" href="#ampersand-collection-serialize"><h3><span class="header-link"></span>serialize <code>collection.serialize()</code></h3></a><p>Serialize the collection into a plain javascript array, ready for sending to the server (typically called via <a href="#ampersand-state-tojson">toJSON</a>). Will also call <code>serialize()</code> on each model in the collection.</p>
<a name="ampersand-collection-tojson" class="anchor" href="#ampersand-collection-tojson"><h3><span class="header-link"></span>toJSON <code>collection.toJSON()</code></h3></a><p>Returns a plain javascript array of the models in the collection (which are also serialized) ready for sending to the server. The name of this method is a bit confusing, as it doesn&#39;t actually return a JSON string — but I&#39;m afraid that it&#39;s the way that the JavaScript API for JSON.stringify works.</p>
<pre><code class="undefinedjavascript">var collection = new AmpersandCollection([
    {name: &quot;Tim&quot;, age: 5},
    {name: &quot;Ida&quot;, age: 26},
    {name: &quot;Rob&quot;, age: 55}
]);

console.log(JSON.stringify(collection));
//=&gt; &quot;[{\&quot;name\&quot;:\&quot;Tim\&quot;,\&quot;age\&quot;:5},{\&quot;name\&quot;:\&quot;Ida\&quot;,\&quot;age\&quot;:26},{\&quot;name\&quot;:\&quot;Rob\&quot;,\&quot;age\&quot;:55}]&quot;
</code></pre>
<a name="ampersand-collection-set" class="anchor" href="#ampersand-collection-set"><h3><span class="header-link"></span>set <code>collection.set(models, [options])</code></h3></a><p>The <strong>set</strong> method performs a &quot;smart&quot; update of the collection with the passed list of models. If a model in the list isn&#39;t yet in the collection it will be added; if the model is already in the collection its attributes will be merged; and if the collection contains any models that aren&#39;t present in the list, they&#39;ll be removed. All of the appropriate <code>&quot;add&quot;</code>, <code>&quot;remove&quot;</code>, and <code>&quot;change&quot;</code> events are fired as this happens. Returns the touched models in the collection. If you&#39;d like to customize the behavior, you can disable it with options: <code>{add: false}</code>, <code>{remove: false}</code>, or <code>{merge: false}</code>.</p>
<pre><code class="undefinedjavascript">var vanHalen = new AmpersandCollection([eddie, alex, stone, roth]);

vanHalen.set([eddie, alex, stone, hagar]);

// Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for &quot;hagar&quot;.
// Updates any of stone, alex, and eddie&#39;s attributes that may have
// changed over the years.
</code></pre>
<a name="ampersand-collection-get" class="anchor" href="#ampersand-collection-get"><h3><span class="header-link"></span>get <code>collection.get(query, [indexName])</code></h3></a><p>Retrieve a model from the collection by index.</p>
<p>With an unspecified <code>indexName</code> (<code>collection.get(123)</code>) retrieves the model by it&#39;s <a href="#ampersand-collection-mainindex">mainIndex</a> attribute.</p>
<p>Or specify an <code>indexName</code> to retrieve a model by any of the other listed <a href="#ampersand-collection-indexes">indexes</a>.</p>
<pre><code class="undefinedjavascript">var People = AmpersandCollection.extend({
    mainIndex: &#39;_id&#39;,

    indexes: [&#39;otherId&#39;]
});

var people = new People.add([
    { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; },
    { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
    { _id: 3, otherId: &#39;c&#39;, name: &#39;Henrik&#39; },
    { _id: 4, otherId: &#39;d&#39;, name: &#39;Jenn&#39; }
]);

people.get(1) //=&gt; { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; }

people.get(&#39;b&#39;, &#39;otherId&#39;) //=&gt; { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
</code></pre>
<a name="ampersand-collection-at" class="anchor" href="#ampersand-collection-at"><h3><span class="header-link"></span>at <code>collection.at(index)</code></h3></a><p>Get a model from a collection, specified by index. Useful if your collection is sorted, and if your collection isn&#39;t sorted, at will still retrieve models in insertion order.</p>
<p>e.g. <code>collection.at(0)</code> returns the first model in the collection.</p>
<a name="ampersand-collection-remove" class="anchor" href="#ampersand-collection-remove"><h3><span class="header-link"></span>remove <code>collection.remove(models, [options])</code></h3></a><p>Remove a model (or an array of models) from the collection, and returns them. Fires a <code>&quot;remove&quot;</code> event, which you can use <code>{ silent: true }</code> to suppress. The model&#39;s index before removal is available to listeners as <code>options.index</code>.</p>
<p>The models object/array can be references to actual models, or just a list of ids to remove.</p>
<a name="ampersand-collection-reset" class="anchor" href="#ampersand-collection-reset"><h3><span class="header-link"></span>reset <code>collection.reset(models, [options])</code></h3></a><p>Adding and removing models one at a time is all well and good, but sometimes you have so many models to change that you&#39;d rather just update the collection in bulk. Use <strong>reset</strong> to replace a collection with a new list of models (or attribute hashes), triggering a single <code>&quot;reset&quot;</code> event at the end. Returns the newly-set models. For convenience, within a <code>&quot;reset&quot;</code> event, the list of any previous models is available as <code>options.previousModels</code>.</p>
<p>Calling <code>collection.reset()</code> without passing any models as arguments will empty the entire collection.</p>
<a name="ampersand-collection-sort" class="anchor" href="#ampersand-collection-sort"><h3><span class="header-link"></span>sort <code>collection.sort([options])</code></h3></a><p>Force a collection to re-sort itself. You don&#39;t need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a model is added. To disable sorting when adding a model, pass <code>{sort: false}</code> to add. Calling sort triggers a <code>&quot;sort&quot;</code> event on the collection.</p>
<a name="ampersand-collection-models" class="anchor" href="#ampersand-collection-models"><h3><span class="header-link"></span>models <code>collection.models</code></h3></a><p>Raw access to the JavaScript array of models inside of the collection. Usually you&#39;ll want to use <code>get</code>, <code>at</code>, or the <a href="#proxied-es5-array-methods-9">proxied array methods</a> to access model objects, but occasionally a direct reference to the array is desired.</p>
<a name="ampersand-collection-" class="anchor" href="#ampersand-collection-"><h3><span class="header-link"></span><strong>proxied ES5 array methods (9)</strong></h3></a><p>The base AmpersandCollection proxies some basic ES5 methods to the underlying model array. Further documentation of these methods is available at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods">MDN</a></p>
<ul>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>every</li>
<li>some</li>
<li>forEach</li>
<li>each (alias for forEach)</li>
<li>map</li>
<li>filter</li>
<li>reduce</li>
<li>reduceRight</li>
</ul>
<p>Unlike a backbone collection it does not include underscore and all the array methods from underscore, though if you wish more functions than those built into modern browsers, you can mixin <a href="#ampersand-collection-underscore-mixin">ampersand-collection-underscore-mixin</a> to get them.</p>
<pre><code class="undefinedjavascript">var people = People([
    { name: &#39;Phil&#39;, hatColor: &#39;red&#39; },
    { name: &#39;Jenn&#39;, hatColor: &#39;green&#39; },
    { name: &#39;Henrik&#39;, hatColor: &#39;blue&#39; },
    { name: &#39;Julie&#39;, hatColor: &#39;yellow&#39; }
]);

people.map(function (person) { return person.name; }) //=&gt; [&#39;Phil&#39;, &#39;Jenn&#39;, &#39;Henrik&#39;, &#39;Julie&#39;]

people.filter(function (person) {
    return person.name[0] === &#39;J&#39;;
}) //=&gt; [&#39;Jenn&#39;, &#39;Julie&#39;]
</code></pre>
</div>
        </section>
        <section class="module"><a name="ampersand-rest-collection" href="#ampersand-rest-collection" class="anchor">
            <h1><span class="header-link"></span>ampersand-rest-collection</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-rest-collection</h4>
            <p class="module-version">latest v1.0.4</p>
            <p class="module-description">ampersand-collection with REST and Underscore mixins.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-rest-collection">github</a><a href="https://www.npmjs.org/package/ampersand-rest-collection">npm</a></p>
          </div>
          <div><p>Extends ampersand-collection with REST and Underscore mixins.</p>
<p>This makes ampersand-collection work and act a lot like Backbone.Collection, if youre planning on hitting a REST-ful API this is probably what you want to use.</p>
<a name="ampersand-rest-collection-install" class="anchor" href="#ampersand-rest-collection-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-rest-collection
</code></pre><a name="ampersand-rest-collection-api-reference" class="anchor" href="#ampersand-rest-collection-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><p>The ampersand-rest-collection is simply an <a href="#ampersand-collection">ampersand-collection</a> extended with two mixins: ampersand-collection-rest-mixin and ampersand-collection-underscore-mixin.</p>
<pre><code class="undefinedjavascript">var Collection = require(ampersand-collection);
var underscoreMixin = require(ampersand-collection-underscore-mixin);
var restMixins = require(ampersand-collection-rest-mixin);

module.exports = Collection.extend(underscoreMixin, restMixins);
</code></pre>
<a name="ampersand-rest-collection-ajaxconfig" class="anchor" href="#ampersand-rest-collection-ajaxconfig"><h3><span class="header-link"></span>ajaxConfig <code>AmpersandRestCollection.extend({ ajaxConfig: function () { ... } })</code></h3></a><p>ampersand-sync will call ajaxConfig on your collection before it makes the request to the server, passing it the request parameters. When extending your own collection, set an ajaxConfig function to modify the request before it goes to the server. Useful for setting headers/CORS options etc.</p>
<p>The function will be called with <code>params</code> as the first argument, which is the object which will be passed to the underling <code>jQuery.ajax</code> call by ampersand-sync.</p>
<pre><code class="undefinedjavascript">var MyCollection = AmpersandRestCollection.extend({
    url: &#39;http://otherdomain.example.com/stuff&#39;,

    ajaxConfig: function (params) {
        //Enable CORS requests
        params.crossDomain = true;

        //Send cookies cross domain for auth
        params.xhrFields = params.xhrFields || {};
        params.xhrFields.withCredentials = true;

        return params;
    }
});

var collection = new MyCollection()
collection.fetch();
</code></pre>
<a name="ampersand-rest-collection-fetch" class="anchor" href="#ampersand-rest-collection-fetch"><h3><span class="header-link"></span>fetch <code>collection.fetch([options])</code></h3></a><p>Fetch the default set of models for the collection from the server, <a href="#ampersand-collection-set">setting</a> them on the collection when they arrive. If the collection already contains data, by default, the operation of <a href="#ampersand-collection-set">set</a> will add new models from the server, merge the attributes of existing ones, and remove any which aren&#39;t in the response. This behaviour can be modified with the <code>reset</code>, <code>add</code>, <code>remove</code>, <code>merge</code> options.</p>
<p>Options:</p>
<ul>
<li><code>success</code> {Function} [optional] - callback to be called if the request was successful, will be passed <code>(collection, response, options)</code> as arguments.</li>
<li><code>error</code> {Function} [optional] - callback to be called if the request was not successful, will be passed <code>(collection, response, options)</code> as arguments.</li>
<li><code>reset</code> {Boolean} [optional] - call <a href="#ampersand-collection-reset">reset</a> instead of set with the models returned from the server, <em>defaults to false</em>.</li>
<li><code>add</code> {Boolean} [optional] - (assuming <code>reset</code> is false), <code>{add: false}</code> prevents the call to <code>set</code> from adding new models retrieved from the server that aren&#39;t in the local collection. <em>Defaults to false</em></li>
<li><code>remove</code> {Boolean} [optional] - (assuming <code>reset</code> is false), <code>{remove: false}</code> prevents the call to <code>set</code> from removing models that are in the local collection but aren&#39;t returned by the server. <em>Defaults to false</em></li>
<li><code>merge</code> {Boolean} [optional] - (assuming <code>reset</code> is false), <code>{merge: false}</code> prevents the call to <code>set</code> from updating models in the local collection which have changed on the server. <em>Defaults to false</em></li>
</ul>
<p>You can also pass any options that <code>jQuery.ajax</code> expects to modify the query. For example: to fetch a specific page of a paginated collection: <code>collection.fetch({ data: { page: 3 } })</code></p>
<a name="ampersand-rest-collection-create" class="anchor" href="#ampersand-rest-collection-create"><h3><span class="header-link"></span>create <code>collection.create(model, [options])</code></h3></a><p>Convenience to create a new instance of a model within a collection. Equivalent to instantiating a model with a hash of attributes, saving the model to the server, and adding the model to the set after being successfully created. Returns the new model. If client-side validation failed, the model will be unsaved, with validation errors. In order for this to work, you should set the <code>model</code> property of the collection. The create method can accept either an attributes hash or an existing, unsaved model object.</p>
<p>Creating a model will cause an immediate <code>&quot;add&quot;</code> event to be triggered on the collection, a <code>&quot;request&quot;</code> event as the new model is sent to the server, as well as a <code>&quot;sync&quot;</code> event, once the server has responded with the successful creation of the model. Pass <code>{wait: true}</code> if you&#39;d like to wait for the server before adding the new model to the collection.</p>
<pre><code>var Library = AmpersandRestCollection.extend({
  model: Book
});

var library = new Library;

var othello = library.create({
  title: &quot;Othello&quot;,
  author: &quot;William Shakespeare&quot;
});
</code></pre><a name="ampersand-rest-collection-sync" class="anchor" href="#ampersand-rest-collection-sync"><h3><span class="header-link"></span>sync <code>model.sync(method, collection, [options])</code></h3></a><p>Simple delegation to ampersand-sync to persist the collection to the server. Can be overridden for custom behaviour.</p>
<a name="ampersand-rest-collection-underscore-methods-42" class="anchor" href="#ampersand-rest-collection-underscore-methods-42"><h3><span class="header-link"></span>underscore methods (42)</h3></a><p>The ampersand-collection-underscore-mixin proxies the collection methods in underscore onto the underlying models array for the collection. For example:</p>
<pre><code class="undefinedjavascript">books.each(function(book) {
  book.publish();
});

var titles = books.map(function(book) {
  return book.get(&quot;title&quot;);
});

var publishedBooks = books.filter(function(book) {
  return book.get(&quot;published&quot;) === true;
});

var alphabetical = books.sortBy(function(book) {
  return book.author.get(&quot;name&quot;).toLowerCase();
});
</code></pre>
<p>The full list of proxied methods is:</p>
<ul>
<li><a href="http://underscorejs.org/forEach">forEach</a></li>
<li><a href="http://underscorejs.org/each">each</a></li>
<li><a href="http://underscorejs.org/map">map</a></li>
<li><a href="http://underscorejs.org/collect">collect</a></li>
<li><a href="http://underscorejs.org/reduce">reduce</a></li>
<li><a href="http://underscorejs.org/foldl">foldl</a></li>
<li><a href="http://underscorejs.org/inject">inject</a></li>
<li><a href="http://underscorejs.org/reduceRight">reduceRight</a></li>
<li><a href="http://underscorejs.org/foldr">foldr</a></li>
<li><a href="http://underscorejs.org/find">find</a></li>
<li><a href="http://underscorejs.org/detect">detect</a></li>
<li><a href="http://underscorejs.org/filter">filter</a></li>
<li><a href="http://underscorejs.org/select">select</a></li>
<li><a href="http://underscorejs.org/reject">reject</a></li>
<li><a href="http://underscorejs.org/every">every</a></li>
<li><a href="http://underscorejs.org/all">all</a></li>
<li><a href="http://underscorejs.org/some">some</a></li>
<li><a href="http://underscorejs.org/any">any</a></li>
<li><a href="http://underscorejs.org/include">include</a></li>
<li><a href="http://underscorejs.org/contains">contains</a></li>
<li><a href="http://underscorejs.org/invoke">invoke</a></li>
<li><a href="http://underscorejs.org/max">max</a></li>
<li><a href="http://underscorejs.org/min">min</a></li>
<li><a href="http://underscorejs.org/toArray">toArray</a></li>
<li><a href="http://underscorejs.org/size">size</a></li>
<li><a href="http://underscorejs.org/first">first</a></li>
<li><a href="http://underscorejs.org/head">head</a></li>
<li><a href="http://underscorejs.org/take">take</a></li>
<li><a href="http://underscorejs.org/initial">initial</a></li>
<li><a href="http://underscorejs.org/rest">rest</a></li>
<li><a href="http://underscorejs.org/tail">tail</a></li>
<li><a href="http://underscorejs.org/drop">drop</a></li>
<li><a href="http://underscorejs.org/last">last</a></li>
<li><a href="http://underscorejs.org/without">without</a></li>
<li><a href="http://underscorejs.org/difference">difference</a></li>
<li><a href="http://underscorejs.org/indexOf">indexOf</a></li>
<li><a href="http://underscorejs.org/shuffle">shuffle</a></li>
<li><a href="http://underscorejs.org/lastIndexOf">lastIndexOf</a></li>
<li><a href="http://underscorejs.org/isEmpty">isEmpty</a></li>
<li><a href="http://underscorejs.org/chain">chain</a></li>
<li><a href="http://underscorejs.org/sample">sample</a></li>
<li><a href="http://underscorejs.org/partition">partition</a></li>
</ul>
</div>
        </section>
        <section class="module"><a name="ampersand-view" href="#ampersand-view" class="anchor">
            <h1><span class="header-link"></span>ampersand-view</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-view</h4>
            <p class="module-version">latest v5.1.11</p>
            <p class="module-version">beta v2.4.0</p>
            <p class="module-description">A smart base view for Backbone apps, to make it easy to bind collections and properties to the DOM.</p>
            <p class="module-links"><a href="http://ampersandjs.com">github</a><a href="https://www.npmjs.org/package/ampersand-view">npm</a></p>
          </div>
          <div><p>A set of common helpers and conventions for using as a base view for ampersand.js apps.</p>
<p>What does it do?</p>
<ol>
<li>Gives you a proven pattern for managing/binding the contents of an element.</li>
<li>Simple declarative property/template bindings without needing to include a template engine that does it for you. This keeps your logic out of your templates and lets you use a string of HTML as a fully dynamic template or just a simple function that returns an HTML string.</li>
<li>The view&#39;s base element is replaced (or created) during a render. So, rather than having to specify tag type and attributes in javascript in the view definition you can just include that in your template like everything else.</li>
<li>A way to render a collection of models within an element in the view, each with their own view, preserving order, and doing proper cleanup when the main view is removed.</li>
<li>A simple way to render sub-views that get cleaned up when the parent view is removed.</li>
</ol>
<a name="ampersand-view-install" class="anchor" href="#ampersand-view-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-view
</code></pre><a name="ampersand-view-api-reference" class="anchor" href="#ampersand-view-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><p>Note that this is a fork of Backbone&#39;s view so most of the public methods/properties here still exist: <a href="http://backbonejs.org/#View">http://backbonejs.org/#View</a>.</p>
<a name="ampersand-view-extend" class="anchor" href="#ampersand-view-extend"><h3><span class="header-link"></span>extend <code>AmpersandView.extend([properties])</code></h3></a><p>Get started with views by creating a custom view class. Ampersand views have a sane default render function, which you don&#39;t necessarily have to override, but you probably will wish to specify a <a href="#ampersand-view-template"><code>template</code></a>, your declarative <a href="#ampersand-view-events">event handlers</a> and your <a href="#ampersand-view-bindings">view bindings</a>.</p>
<pre><code class="undefinedjavascript">var PersonRowView = AmpersandView.extend({
    template: &quot;&lt;li&gt; &lt;span role=&#39;name&#39;&gt;&lt;/span&gt; &lt;span role=&#39;age&#39;&gt;&lt;/span&gt; &lt;a role=&#39;edit&#39;&gt;edit&lt;/a&gt; &lt;/li&gt;&quot;,

    events: {
        &quot;click [role=edit]&quot;: &quot;edit&quot;
    },

    bindings: {
        &quot;model.name&quot;: {
            type: &#39;text&#39;,
            role: &#39;name&#39;
        },

        &quot;model.age&quot;: {
            type: &#39;text&#39;,
            role: &#39;age&#39;
        }
    },

    edit: funciton () {
        //...
    }
});
</code></pre>
<a name="ampersand-view-template" class="anchor" href="#ampersand-view-template"><h3><span class="header-link"></span>template <code>AmpersandView.extend({ template: &quot;&lt;div&gt;&lt;input&gt;&lt;/div&gt;&quot; })</code></h3></a><p>The <code>.template</code> is a property for the view prototype. It should either be a string of HTML or a function that returns a string of HTML or a DOM element. It isn&#39;t required, but it is used as a default for calling <code>renderWithTemplate</code>.</p>
<p>The important thing to note is that <strong><em>the returned string/HTML should not have more than one root element</em></strong>. This is because the view code assumes that it has one and only one root element that becomes the <code>.el</code> property of the instantiated view.</p>
<p>For more information about creating, and compiling templates, <a href="http://ampersandjs.com/learn/templates">read the templating guide</a>.</p>
<a name="ampersand-view-autorender" class="anchor" href="#ampersand-view-autorender"><h3><span class="header-link"></span>autoRender <code>AmpersandView.extend({ autoRender: true })</code></h3></a><p>The <code>.autoRender</code> property lets you optionally specify that the view should just automatically render with all the defaults. This requires that you at minimum specify a <a href="#template">template</a> string of function.</p>
<p>By setting <code>autoRender: true</code> the view will simply call <code>.renderWithTemplate</code> for you (after your <code>initialize</code> method if present). So for simple views, if you&#39;ve got a few bindings and a template your whole view could just be really and declarative like this:</p>
<pre><code class="undefinedjavascript">var AmpersandView = require(&#39;ampersand-view&#39;);


module.exports = AmpersandView.extend({
    autoRender: true,
    template: &#39;&lt;div&gt;&lt;span id=&quot;username&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#39;,
    bindings: {
        name: &#39;#username&#39;
    }
});
</code></pre>
<p><strong>Note:</strong> if you are using a template function (and not a string) the template function will get called with a context argument that looks like this, giving you access to <code>.model</code>, <code>.collection</code> and any other props you have defined on the view from the template.</p>
<pre><code class="undefinedjavascript">this.renderWithTemplate(this, this.template);
</code></pre>
<a name="ampersand-view-events" class="anchor" href="#ampersand-view-events"><h3><span class="header-link"></span>events <code>AmpersandView.extend({ events: { /* ...events hash... */ } })</code></h3></a><p>The events hash allows you to specify declarative callbacks for DOM events within the view. This is much clearer and less complex than calling <code>$(&#39;selector&#39;).on(&#39;click&#39;, ...)</code> or <code>el.addEventListener(&#39;click&#39;, ...)</code> everywhere.</p>
<ul>
<li>Events are written in the format <code>{&quot;event selector&quot;: &quot;callback&quot;}</code>.</li>
<li>The callback may either be the name of a method on the view, or an actual function.</li>
<li>Omitting the <code>selector</code> causes the event to be bound to the view&#39;s root element (<code>this.el</code>).</li>
<li>The events property may also be defined as a function that returns an <em>events</em> hash, to make it easier to programmatically define your events, as well as inherit them from parent views.</li>
</ul>
<p>Using the events hash has a number of benefits over manually binding events during the <code>render</code> call:</p>
<ul>
<li>All attached callbacks are bound to the view before being handed off to the event handler, so when the callbacks are invoked, <code>this</code> continues to refer to the view object.</li>
<li>All event handlers are delegated to the view&#39;s root el, meaning elements changed when the view is updated don&#39;t need to be unbound and rebound.</li>
<li>All events handlers are cleanly remvoed when the view is <a href="#ampersand-view-remove">removed</a>.</li>
</ul>
<pre><code>var DocumentView = AmpersandView.extend({

  events: {
    //bind to a double click on the root element
    &quot;dblclick&quot;                : &quot;open&quot;,

    //bind to a click on an element with both &#39;icon&#39; and &#39;doc&#39; classes
    &quot;click .icon.doc&quot;         : &quot;select&quot;,

    &quot;contextmenu .icon.doc&quot;   : &quot;showMenu&quot;,
    &quot;click .show_notes&quot;       : &quot;toggleNotes&quot;,
    &quot;click .title .lock&quot;      : &quot;editAccessLevel&quot;,
    &quot;mouseover .title .date&quot;  : &quot;showTooltip&quot;
  },

  open: function() {
    window.open(this.model.viewer_url);
  },

  select: function() {
    this.model.selected = true;
  },

  //...

});
</code></pre><a name="ampersand-view-bindings" class="anchor" href="#ampersand-view-bindings"><h3><span class="header-link"></span>bindings</h3></a><p>The bindings hash gives you a declarative way of specifying which elements in your view should be updated when the view&#39;s model is changed.</p>
<p>For a full reference of available binding types see: <a href="https://github.com/henrikjoreteg/dom-bindings#binding-types">henrikjoreteg/dom-bindings</a>.</p>
<p>For example, with a model like this:</p>
<pre><code class="undefinedjavascript">var Person = AmpersandModel.extend({
    props: {
        name: &#39;string&#39;,
        age: &#39;number&#39;,
        avatarURL: &#39;string&#39;
    },
    session: {
        selected: &#39;boolean&#39;
    }
});
</code></pre>
<p>and a template like this:</p>
<pre><code class="undefinedhtml">&lt;!-- templates.person --&gt;
&lt;li&gt;
  &lt;img role=&quot;avatar&quot;&gt;
  &lt;span role=&quot;name&quot;&gt;&lt;/span&gt;
  age: &lt;span role=&quot;age&quot;&gt;&lt;/span&gt;
&lt;/li&gt;
</code></pre>
<p>you might have a binding hash in your view like this:</p>
<pre><code class="undefinedjavascript">var PersonView = AmpersandView.extend({
    templates: templates.person,

    bindings: {
        &#39;model.name&#39;: {
            type: &#39;text&#39;,
            role: &#39;name&#39;
        },

        &#39;model.age&#39;: &#39;[role=age]&#39;, //shorthand of the above

        &#39;model.avatarURL&#39;: {
            type: &#39;attribute&#39;,
            name: &#39;src&#39;,
            role: &#39;avatar&#39;
        },

        //no selector, selects the root element
        &#39;model.selected&#39;: {
            type: &#39;booleanClass&#39;,
            name: &#39;active&#39; //class to toggle
        }
    }
});
</code></pre>
<a name="ampersand-view-el" class="anchor" href="#ampersand-view-el"><h3><span class="header-link"></span>el <code>view.el</code></h3></a><p>All rendered views have a single DOM node which they manage, which is acessible from the <code>.el</code> property on the view. Allowing you to insert it into the DOM from the parent context.</p>
<pre><code>var view = new PersonView({ model: me });
view.render();

document.querySelector(&#39;#viewContainer&#39;).appendChild(view.el);
</code></pre><a name="ampersand-view-constructor" class="anchor" href="#ampersand-view-constructor"><h3><span class="header-link"></span>constructor <code>new AmpersandView([options])</code></h3></a><p>The default <code>AmpersandView</code> constructor accepts an optional <code>options</code> object, and:</p>
<ul>
<li>Attaches the following options directly to the instaniated view, overriding the defaults: <code>model</code>, <code>collection</code>, <code>el</code>.</li>
<li>Sets up event bindings defined in the <code>events</code> hash.</li>
<li>Sets up the model bindings defined in the <code>bindings</code> hash.</li>
<li>Initializes any subviews defined in the <code>subviews</code> hash.</li>
<li>Calls <code>initialize</code> passing it the options hash.</li>
<li>Renders the view, if <code>autoRender</code> is true and a template is defined.</li>
</ul>
<p>Typical use-cases for the options hash:</p>
<ul>
<li>To initialize a view with an <code>el</code> <em>already</em> in the DOM, pass it as an option: <code>new AmpersandView({ el: existingElement })</code>.</li>
<li>To perform extra work when initializing a new view, override the <code>initialize</code> function in the extend call, rather than modifying the constructor, it&#39;s easier.</li>
</ul>
<a name="ampersand-view-initialize" class="anchor" href="#ampersand-view-initialize"><h3><span class="header-link"></span>initialize <code>new AmpersandView([options])</code></h3></a><p>Called by the default view constructor after the view is initialized. Overwrite initialize in your views to perform some extra work when the view is initialized. Initially it&#39;s a noop:</p>
<pre><code class="undefinedjavascript">var MyView = AmpersandView.extend({
    initialize: function (options) {
        console.log(&quot;The options are:&quot;, options);
    }
});

var view = new MyView({ foo: &#39;bar&#39; });
//=&gt; logs &#39;The options are: {foo: &quot;bar&quot;}&#39;
</code></pre>
<a name="ampersand-view-render" class="anchor" href="#ampersand-view-render"><h3><span class="header-link"></span>render <code>view.render()</code></h3></a><p>Render is a part of the <a href="???">Ampersand View conventions</a>. You can override the default view method when extending AmpersandView if you wish, but as part of the conventions, calling render should:</p>
<ul>
<li>Create a <code>this.el</code> property if the view doesn&#39;t already have one, and populate it with your view template</li>
<li>or if the view already has a <code>this.el</code> attribute, render should either populate it with your view template, or create a new element and replace the existing <code>this.el</code> if it&#39;s in the DOM tree.</li>
<li>Not be a problem if it&#39;s called more than once.</li>
</ul>
<p>The default render looks like this:</p>
<pre><code class="undefinedjavascript">render: function () {
    this.renderWithTemplate(this);
    return this;
}
</code></pre>
<a name="ampersand-view-rendercollection" class="anchor" href="#ampersand-view-rendercollection"><h3><span class="header-link"></span>renderCollection <code>view.renderCollection(collection, ItemView, containerEl, [viewOptions])</code></h3></a><ul>
<li><code>collection</code> {Backbone Collection} The instantiated collection we wish to render.</li>
<li><code>itemViewClass</code> {View Constructor} The view constructor that will be instantiated for each model in the collection. This view will be instantiated with a reference to the model and collection and the item view&#39;s <code>render</code> method will be called with an object containing a reference to the containerElement as follows: <code>.render({containerEl: &lt;&lt; element &gt;&gt;})</code>.</li>
<li><code>containerEl</code> {Element} The element that should hold the collection of views.</li>
<li><code>viewOptions</code> {Object} [optional] Additional options <ul>
<li><code>viewOptions</code> {Object} Options object that will get passed to the <code>initialize</code> method of the individual item views.</li>
<li><code>filter</code> {Function} [optional] Function that will be used to determine if a model should be rendered in this collection view. It will get called with a model and you simply return <code>true</code> or <code>false</code>.</li>
<li><code>reverse</code> {Boolean} [optional] Convenience for reversing order in which the items are rendered.</li>
</ul>
</li>
</ul>
<p>This method will maintain this collection within that container element. Including proper handling of add, remove, sort, reset, etc.</p>
<p>Also, when the parent view gets <code>.remove()</code>&#39;ed any event handlers registered by the individual item views will be properly removed as well.</p>
<p>Each item view will only be <code>.render()</code>&#39;ed once (unless you change that within the item view itself).</p>
<a name="ampersand-view-example" class="anchor" href="#ampersand-view-example"><h4><span class="header-link"></span>Example:</h4></a><pre><code class="undefinedjavascript">// some view for individual items in the collection
var ItemView = AmpersandView.extend({ ... });

// the main view
var MainView = AmpersandView.extend({
    template: &#39;&lt;section class=&quot;page&quot;&gt;&lt;ul class=&quot;itemContainer&quot;&gt;&lt;/ul&gt;&lt;/section&gt;&#39;,
    render: function (opts) {
        // render our template as usual
        this.renderWithTemplate(this);

        // call renderCollection with these arguments:
        // 1. collection
        // 2. which view to use for each item in the list
        // 3. which element within this view to use as the container
        // 4. options object (not required):
        //      {
        //          // function used to determine if model should be included
        //          filter: function (model) {},
        //          // boolean to specify reverse rendering order
        //          reverse: false,
        //          // view options object (just gets passed to item view&#39;s `initialize` method)
        //          viewOptions: {}
        //      }
        this.renderCollection(this.collection, ItemView, this.$(&#39;.itemContainer&#39;)[0], opts);
        return this;
    }
})
</code></pre>
<a name="ampersand-view-registersubview" class="anchor" href="#ampersand-view-registersubview"><h3><span class="header-link"></span>registerSubview <code>view.registerSubview(viewInstance)</code></h3></a><ul>
<li>viewInstance {Object} Any object with a &quot;remove&quot; method, typically an instantiated view. But doesn&#39;t have to be, it can be anything with a remove method. The remove method doesn&#39;t have to actually remove itself from the DOM (since the parent view is being removed anyway), it is generally just used for unregistering any handler that it set up.</li>
</ul>
<a name="ampersand-view-rendersubview" class="anchor" href="#ampersand-view-rendersubview"><h3><span class="header-link"></span>renderSubview <code>view.renderSubview(viewInstance, containerEl)</code></h3></a><ul>
<li>viewInstance {Object} Any object with a <code>.remove()</code>, <code>.render()</code> and an <code>.el</code> property that is the DOM element for that view. Typically this is just an instantiated view. </li>
<li>containerEl {Element | String | jQueryElement} This can either be an actual DOM element or a CSS selector string such as <code>.container</code>. If a string is passed human view runs <code>this.$(&quot;YOUR STRING&quot;)</code> to try to grab the element that should contain the sub view.</li>
</ul>
<p>This method is just sugar for the common use case of instantiating a view and putting in an element within the parent.</p>
<p>It will:</p>
<ol>
<li>fetch your container (if you gave it a selector string)</li>
<li>register your subview so it gets cleaned up if parent is removed and so <code>view.parent</code> will be available when your subview&#39;s <code>render</code> method gets called</li>
<li>call the subview&#39;s <code>render()</code> method</li>
<li>append it to the container</li>
<li>return the subview</li>
</ol>
<pre><code class="undefinedjs">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/li&gt;&#39;,
    render: function () {
        this.renderWithTemplate();

        //...

        var model = this.model;
        this.renderSubview(new SubView({
            model: model
        }), &#39;.container&#39;);

        //...

    }
});
</code></pre>
<a name="ampersand-view-renderwithtemplate" class="anchor" href="#ampersand-view-renderwithtemplate"><h3><span class="header-link"></span>renderWithTemplate <code>view.renderWithTemplate([context], [template])</code></h3></a><ul>
<li><code>context</code> {Object | null} [optional] The context that will be passed to the template function, usually it will be passed the view itself, so that <code>.model</code>, <code>.collection</code> etc are available.</li>
<li><code>template</code> {Function | String} [optional] A function that returns HTML or a string of HTML.</li>
</ul>
<p>This is shortcut for the default rendering you&#39;re going to do in most every render method, which is: use the template property of the view to replace <code>this.el</code> of the view and re-register all handlers from the event hash and any other binding as described above.</p>
<pre><code class="undefinedjavascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;&#39;,
    bindings: {
        &#39;name&#39;: &#39;a&#39;
    },
    events: {
        &#39;click a&#39;: &#39;handleLinkClick&#39;
    },
    render: function () {
        // this does everything
        // 1. renders template
        // 2. registers delegated click handler
        // 3. inserts and binds the &#39;name&#39; property
        //    of the view&#39;s `this.model` to the &lt;a&gt; tag.
        this.renderWithTemplate();
    }
});
</code></pre>
<a name="ampersand-view-get" class="anchor" href="#ampersand-view-get"><h3><span class="header-link"></span>get <code>view.get(&#39;.classname&#39;)</code></h3></a><p>Runs a <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.querySelector"><code>querySelector</code></a> scoped within the view&#39;s current element (<code>view.el</code>), returning the first matching element in the dom-tree.</p>
<pre><code class="undefinedjavascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;img role=&quot;avatar&quot; src=&quot;&quot;&gt;&lt;/li&gt;&#39;,
    render: function () {
        this.renderWithTemplate(this);

        // cache an element for easy reference by other methods
        this.imgEl = this.get(&quot;[role=avatar]&quot;);

        return this;
    }
});
</code></pre>
<a name="ampersand-view-getbyrole" class="anchor" href="#ampersand-view-getbyrole"><h3><span class="header-link"></span>getByRole <code>view.getByRole(&#39;rolename&#39;)</code></h3></a><p>A convenience method for retrieving an element from the current view by role. Using the role attribute is a nice way to separate javascript view hooks/bindings from class/id selectors that are being used by css:</p>
<pre><code class="undefinedjavascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;img class=&#39;avatar-rounded&#39; role=&quot;avatar&quot; src=&quot;&quot;&gt;&lt;/li&gt;&#39;,
    render: function () {
        this.renderWithTemplate(this);

        // cache an element for easy reference by other methods
        this.imgEl = this.getByRole(&#39;avatar&#39;);

        return this;
    }
});
</code></pre>
<a name="ampersand-view-getall" class="anchor" href="#ampersand-view-getall"><h3><span class="header-link"></span>getAll <code>view.getAll(&#39;.classname&#39;)</code></h3></a><p>Runs a <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.querySelectorAll"><code>querySelectorAll</code></a> scoped within the view&#39;s current element (<code>view.el</code>), returning all the matching elements in the dom-tree.</p>
<a name="ampersand-view-cacheelements" class="anchor" href="#ampersand-view-cacheelements"><h3><span class="header-link"></span>cacheElements <code>view.cacheElements(hash)</code></h3></a><p>A shortcut for adding reference to specific elements within your view for access later. This is avoids excessive DOM queries and makes it easier to update your view if your template changes.</p>
<p>In your <code>render</code> method. Use it like so:</p>
<pre><code class="undefinedjavascript">render: function () {
  this.renderWithTemplate(this);

  this.cacheElements({
    pages: &#39;#pages&#39;,
    chat: &#39;#teamChat&#39;,
    nav: &#39;nav#views ul&#39;,
    me: &#39;#me&#39;,
    cheatSheet: &#39;#cheatSheet&#39;,
    omniBox: &#39;[role=omnibox]&#39;
  });

  return this;
}
</code></pre>
<p>Then later you can access elements by reference like so: <code>this.pages</code>, or <code>this.chat</code>.</p>
<a name="ampersand-view-listentoandrun" class="anchor" href="#ampersand-view-listentoandrun"><h3><span class="header-link"></span>listenToAndRun <code>view.listenToAndRun(object, eventsString, callback)</code></h3></a><p>Shortcut for registering a listener for a model and also triggering it right away.</p>
<a name="ampersand-view-remove" class="anchor" href="#ampersand-view-remove"><h3><span class="header-link"></span>remove <code>view.remove()</code></h3></a><p>Removes a view from the DOM, and calls <code>stopListening</code> to remove any bound events that the view has <code>listenTo</code>&#39;d.</p>
<a name="ampersand-view-delegateevents" class="anchor" href="#ampersand-view-delegateevents"><h3><span class="header-link"></span>delegateEvents <code>view.delegateEvents([events])</code></h3></a><p>Creates delegated DOM event handlers for view elements on <code>this.el</code>. If <code>events</code> is omitted, will use the <code>events</code> property on the view.</p>
<p>Generally you won&#39;t need to call <code>delegateEvents</code> yourself, if you define an <code>event</code> hash when extending AmpersandView, <code>delegateEvents</code> will be called for you when the view is initialize.</p>
<p>Events is a hash of  <code>{&quot;event selector&quot;: &quot;callback&quot;}*</code></p>
<p>Will unbind existing events by calling <code>undelegateEvents</code> before binding new ones when called. Allowing you to switch events for different view contexts, or different views bound to the same element.</p>
<pre><code class="undefinedjavascript">{
  &#39;mousedown .title&#39;:  &#39;edit&#39;,
  &#39;click .button&#39;:     &#39;save&#39;,
  &#39;click .open&#39;:       function (e) { ... }
}
</code></pre>
<a name="ampersand-view-undelegateevents" class="anchor" href="#ampersand-view-undelegateevents"><h3><span class="header-link"></span>undelegateEvents <code>view.undelegateEvents()</code></h3></a><p>Clears all callbacks previously bound to the view with <code>delegateEvents</code>.
You usually don&#39;t need to use this, but may wish to if you have multiple views attached to the same DOM element.</p>
</div>
        </section>
        <section class="module"><a name="ampersand-view-switcher" href="#ampersand-view-switcher" class="anchor">
            <h1><span class="header-link"></span>ampersand-view-switcher</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-view-switcher</h4>
            <p class="module-version">latest v0.3.2</p>
            <p class="module-description">A utility for swapping out views inside a container element.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-view-switcher">github</a><a href="https://www.npmjs.org/package/ampersand-view-switcher">npm</a></p>
          </div>
          <div><p>This module does one thing: <em>it helps you swap out views inside of an element</em>. It&#39;s compatible with ampersand-view, backbone views and any view that has an <code>.el</code>, <code>.render</code> and <code>.remove()</code></p>
<p>What might you do with it?</p>
<ul>
<li>build a page container for your app.</li>
<li>build a system for managing display of modals in your single page app.</li>
<li>animate a transition between showing any two views.</li>
</ul>
<p>What it does</p>
<ul>
<li>Takes an instantiated view and renders it in the container.</li>
<li>Removes the existing view from the container and calls <code>remove</code> on it.</li>
<li>Makes it easy to do custom stuff as views are added and removed.</li>
<li>Works either synchronously or asynchronously depending on whether you want to animate transitions between the views.</li>
<li>Makes no assumptions about what your views do or how they&#39;re structured except the following:<ul>
<li>Views should have an <code>.el</code> property that is the root element of the view.</li>
<li>Views should have a <code>.remove()</code> method that cleans up and unbinds methods accordingly.</li>
<li>If your view has a <code>.render()</code> method it will get called before it&#39;s shown.</li>
<li>Beyond this, they could be any object.</li>
</ul>
</li>
<li>IT DOES VERY LITTLE ELSE (and <em>that</em> is a feature)</li>
</ul>
<a name="ampersand-view-switcher-install" class="anchor" href="#ampersand-view-switcher-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-view-switcher
</code></pre><a name="ampersand-view-switcher-example" class="anchor" href="#ampersand-view-switcher-example"><h2><span class="header-link"></span>Example</h2></a><p>Here&#39;s an example of how you might use the view switcher to handle page views within your ampersand app.</p>
<p><code>mainview.js</code></p>
<pre><code class="undefinedjs">var HumanView = require(&#39;ampersand-view&#39;);
var ViewSwitcher = require(&#39;ampersand-view-switcher&#39;);
var templates = require(&#39;./templates&#39;);

module.exports = HumanView.extend({
    template: templates.body,
    render: function () {
        // render our template
        this.renderAndBind();

        // grab the element without our template based on its &quot;role&quot; attribute
        this.pageContainer = this.getByRole(&#39;page-container&#39;);

        // set up our page switcher for that element
        this.pageSwitcher = new ViewSwitcher(this.pageContainer, {
            // here we provide a few things we&#39;d like to do each time
            // we switch pages in the app.
            show: function (newView, oldView) {
                // set our document title
                document.title = newView.pageTitle || &#39;my awesome app&#39;;
                // scroll to the top
                document.body.scrollTop = 0;
                // perhaps store a reference to our current page on our
                // app global for easy access from the browser console.
                app.currentPage = view;
            }
        });
    } 
});
</code></pre>
<p>Or if you wanted to animate them you can do it asynchronously like so:</p>
<pre><code class="undefinedjs">// set up our page switcher for that element
this.pageSwitcher = new ViewSwitcher(this.pageContainer, {
    // whether or not to wait for remove to be done before starting show
    waitForRemove: true,
    // here we provide a few things to do before the element gets
    // removed from the DOM.
    hide: function (oldView, newView, cb) {
        // it&#39;s inserted and rendered for me so we&#39;ll add a class 
        // that has a corresponding CSS transition.
        view.el.classList.add(&#39;animateOut&#39;);
        // give it time to finish (yes there are other ways to do this)
        setTimeout(cb, 1000);
    },
    // here we provide a few things we&#39;d like to do each time
    // we switch pages in the app.
    show: function (view, oldView) {
        // it&#39;s inserted and rendered for me
        document.title = newView.pageTitle || &#39;app name&#39;;
        document.body.scrollTop = 0;

        // store an additional reference, just because
        app.currentPage = newView;

        view.el.classList.add(&#39;animateIn&#39;);
        setTimeout(cb, 2000)
    }
});
</code></pre>
<a name="ampersand-view-switcher-api-reference" class="anchor" href="#ampersand-view-switcher-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-view-switcher-constructor" class="anchor" href="#ampersand-view-switcher-constructor"><h3><span class="header-link"></span>constructor <code>new ViewSwitcher(element, [options])</code></h3></a><ul>
<li><code>element</code> {Element} The DOM element that should contain the views.</li>
<li><code>options</code> {Object} [optinal]<ul>
<li><code>show</code> {Function} [optional] A function that gets called when a view is being shown. It&#39;s passed the new view, the previous view (if relevant), and a callback. If you name 3 incoming arguments for example <code>function (newView, oldView, callback) { ... }</code> the view switcher will wait for you to call the callback before it&#39;s considered ready. If you only use one or two like this: <code>function (newView, oldView) { ... }</code> it won&#39;t wait for you to call a callback.</li>
<li><code>hide</code> {Function} [optional] A function that gets called when a view is being removed. It&#39;s passed the old view, the new view (if relevant), and a callback. If you name 3 incoming arguments for example <code>function (oldView, newView, callback) { ... }</code> the view switcher will wait for you to call the callback before it&#39;s considered ready. If you only use one or two like this: <code>function (oldView, newView) { ... }</code> it won&#39;t wait for you to call a callback.</li>
<li><code>waitForRemove</code> {Boolean} [default: <code>false</code>] Whether or not to wait until your <code>hide</code> animation callback gets called before starting your <code>show</code> animation.</li>
<li><code>empty</code> {Function} [optional] A function that gets called any time the view switcher is empty. Including when you instantiate it without giving it a view to start with.</li>
<li><code>view</code> {View} [optional] A view instance to start with.</li>
</ul>
</li>
</ul>
<pre><code class="undefinedjavascript">var switcher = new ViewSwitcher(document.querySelector(&#39;#pageContainer&#39;));

var view = new MyView({ model: model });

switcher.set(view);
</code></pre>
<a name="ampersand-view-switcher-set" class="anchor" href="#ampersand-view-switcher-set"><h3><span class="header-link"></span>set <code>switcher.set(viewInstance)</code></h3></a><ul>
<li><code>viewInstance</code> {View} The new view to render.</li>
</ul>
<p>The instantiated view switcher has this one main method. Simply call it with the new view you wish to show.</p>
<p>This is most likely going to be an instantiated <a href="https://github.com/ampersandjs/ampersand-view">ampersand-view</a> or Backbone.View, but can be anything that has a <code>.el</code> property that represents that view&#39;s root element and <code>.remove()</code> method that cleans up after itself. In addition if your custom view object has a <code>.render()</code> method it will get called before the view is added to the DOM.</p>
<pre><code class="undefinedjavascript">var switcher = new ViewSwitcher(document.querySelector(&#39;#pageContainer&#39;));

var view = new MyView({ model: model });

switcher.set(view);
</code></pre>
<a name="ampersand-view-switcher-clear" class="anchor" href="#ampersand-view-switcher-clear"><h3><span class="header-link"></span>clear <code>switcher.clear(callback)</code></h3></a><ul>
<li><code>callback</code> {Function} [optional] An optional callback when removed. Useful if you&#39;re doing custom animations.</li>
</ul>
<p>Removes the current view from the view switcher. Calls <code>callback</code> when done if one was provided.`</p>
<pre><code class="undefinedjavascript">var switcher = new ViewSwitcher(document.querySelector(&#39;#pageContainer&#39;));

var view = new MyView({ model: model });

switcher.set(view);

switcher.clear();
</code></pre>
</div>
        </section>
        <section class="module"><a name="ampersand-router" href="#ampersand-router" class="anchor">
            <h1><span class="header-link"></span>ampersand-router</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-router</h4>
            <p class="module-version">latest v1.0.1</p>
            <p class="module-description">Clientside router with fallbacks for browsers that don't support pushState. Mostly lifted from Backbone.js.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-router">github</a><a href="https://www.npmjs.org/package/ampersand-router">npm</a></p>
          </div>
          <div><p>Clientside router with fallbacks for browsers that don&#39;t support pushState. Mostly lifted from <a href="http://backbonejs.org/#Router">Backbone.js</a>.</p>
<p>Ampersand-router also adds a <code>redirectTo</code> method which is handy for doing &quot;internal&quot; redirects without breaking backbutton functionality in the browser.</p>
<a name="ampersand-router-install" class="anchor" href="#ampersand-router-install"><h2><span class="header-link"></span>install</h2></a><pre><code>npm install ampersand-router
</code></pre><a name="ampersand-router-api-reference" class="anchor" href="#ampersand-router-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-router-extend" class="anchor" href="#ampersand-router-extend"><h3><span class="header-link"></span>extend <code>AmpersandRouter.extend(properties)</code></h3></a><p>Get started by creating a custom router class. Define actions that are triggered when certain URL fragments are matched, and provide a <a href="#ampersand-router-routes">routes</a> hash that pairs routes to actions. Note that you&#39;ll want to avoid using a leading slash in your route definitions:</p>
<pre><code class="undefinedjavascript">var AppRouter = AmpersandRouter.extend({

  routes: {
    &quot;help&quot;:                 &quot;help&quot;,    // #help
    &quot;search/:query&quot;:        &quot;search&quot;,  // #search/kiwis
    &quot;search/:query/p:page&quot;: &quot;search&quot;   // #search/kiwis/p7
  },

  help: function() {
    //...
  },

  search: function(query, page) {
    //...
  }

});
</code></pre>
<a name="ampersand-router-routers" class="anchor" href="#ampersand-router-routers"><h3><span class="header-link"></span>routers <code>router.routes</code></h3></a><p>The routes hash maps URLs with parameters to functions on your router (or just direct function definitions, if you prefer), similar to the <a href="#ampersand-view">View</a>&#39;s <a href="#ampersand-view-events">events hash</a>. Routes can contain parameter parts, <code>:param</code>, which match a single URL component between slashes; and splat parts <code>*splat</code>, which can match any number of URL components. Part of a route can be made optional by surrounding it in parentheses <code>(/:optional)</code>.</p>
<p>For example, a route of <code>&quot;search/:query/p:page&quot;</code> will match a fragment of <code>#search/obama/p2</code>, passing <code>&quot;obama&quot;</code> and <code>&quot;2&quot;</code> to the action.</p>
<p>A route of <code>&quot;file/*path&quot;</code> will match <code>#file/nested/folder/file.txt</code>, passing <code>&quot;nested/folder/file.txt&quot;</code> to the action.</p>
<p>A route of <code>&quot;docs/:section(/:subsection)&quot;</code> will match #docs/faq and #docs/faq/installing, passing <code>&quot;faq&quot;</code> to the action in the first case, and passing <code>&quot;faq&quot;</code> and <code>&quot;installing&quot;</code> to the action in the second.</p>
<p>Trailing slashes are treated as part of the URL, and (correctly) treated as a unique route when accessed. <code>docs</code> and <code>docs/</code> will fire different callbacks. If you can&#39;t avoid generating both types of URLs, you can define a <code>&quot;docs(/)&quot;</code> matcher to capture both cases.</p>
<p>When the visitor presses the back button, or enters a URL, and a particular route is matched, the name of the action will be fired as an event, so that other objects can listen to the router, and be notified. In the following example, visiting <code>#help/uploading</code> will fire a <code>route:help</code> event from the router.</p>
<pre><code class="undefinedjavascript">routes: {
  &quot;help/:page&quot;:         &quot;help&quot;,
  &quot;download/*path&quot;:     &quot;download&quot;,
  &quot;folder/:name&quot;:       &quot;openFolder&quot;,
  &quot;folder/:name-:mode&quot;: &quot;openFolder&quot;
}

router.on(&quot;route:help&quot;, function(page) {
  ...
});
</code></pre>
<a name="ampersand-router-constructor-initialize" class="anchor" href="#ampersand-router-constructor-initialize"><h3><span class="header-link"></span>constructor / initialize <code>new Router([options])</code></h3></a><p>When creating a new router, you may pass its routes hash directly as an option, if you choose. All options will also be passed to your <code>initialize</code> function, if defined.</p>
<a name="ampersand-router-route" class="anchor" href="#ampersand-router-route"><h3><span class="header-link"></span>route <code>router.route(route, name, [callback])</code></h3></a><p>Manually create a route for the router, The <code>route</code> argument may be a routing string or regular expression. Each matching capture from the route or regular expression will be passed as an argument to the callback. The <code>name</code> argument will be triggered as a <code>&quot;route:name&quot;</code> event whenever the route is matched. If the <code>callback</code> argument is omitted <code>router[name]</code> will be used instead. Routes added later may override previously declared routes.</p>
<pre><code class="undefinedjavascript">initialize: function(options) {

  // Matches #page/10, passing &quot;10&quot;
  this.route(&quot;page/:number&quot;, &quot;page&quot;, function(number){ ... });

  // Matches /117-a/b/c/open, passing &quot;117-a/b/c&quot; to this.open
  this.route(/^(.*?)\/open$/, &quot;open&quot;);

},

open: function(id) { ... }
</code></pre>
<a name="ampersand-router-navigate" class="anchor" href="#ampersand-router-navigate"><h3><span class="header-link"></span>navigate <code>router.navigate(fragment, [options])</code></h3></a><p>Whenever you reach a point in your application that you&#39;d like to save as a URL, call <em>navigate</em> in order to update the URL. If you wish to also call the route function, set the <code>trigger</code> option to <code>true</code>. To update the URL without creating an entry in the browser&#39;s history, set the <code>replace</code> option to <code>true</code>.</p>
<pre><code class="undefinedjavascript">openPage: function(pageNumber) {
  this.document.pages.at(pageNumber).open();
  this.navigate(&quot;page/&quot; + pageNumber);
}

// Or ...

app.navigate(&quot;help/troubleshooting&quot;, {trigger: true});

// Or ...

app.navigate(&quot;help/troubleshooting&quot;, {trigger: true, replace: true});
</code></pre>
<a name="ampersand-router-redirectto" class="anchor" href="#ampersand-router-redirectto"><h3><span class="header-link"></span>redirectTo <code>router.redirectTo(fragment)</code></h3></a><p>Sometimes you want to be able to redirect to a different route in your application without adding an entry in the browser&#39;s history. RedirectTo is just a shorthand for calling <a href="#ampersand-router-navigate">navigate</a> with both <code>trigger</code> and <code>replace</code> set to <code>true</code>.</p>
<pre><code class="undefinedjavascript">var AppRouter = AmpersandRouter.extend({
    routes: {
        &#39;login&#39;: &#39;login&#39;,
        &#39;dashboard&#39;: &#39;dashboard&#39;
    },

    dashboard: function () {
        if (!app.me.loggedIn) return redirectTo(&#39;login&#39;);

        // show dashboard page...
    }
});
</code></pre>
<a name="ampersand-router-execute" class="anchor" href="#ampersand-router-execute"><h3><span class="header-link"></span>execute <code>router.execute(callback, args)</code></h3></a><p>This method is called internally within the router, whenever a route matches and its corresponding callback is about to be executed. Override it to perform custom parsing or wrapping of your routes, for example, to parse query strings before handing them to your route callback, like so:</p>
<pre><code class="undefinedjavascript">var Router = AmpersandRouter.extend({
  execute: function(callback, args) {
    args.push(parseQueryString(args.pop()));
    if (callback) callback.apply(this, args);
  }
});
</code></pre>
<a name="ampersand-router-historystart" class="anchor" href="#ampersand-router-historystart"><h3><span class="header-link"></span>history.start <code>router.history.start([options])</code></h3></a><p>AmpersandRouter automatically requires and instantiates a single ampersand-history object. AmpersandHistory serves as a global router (per frame) to handle hashchange events or pushState, match the appropriate route, and trigger callbacks. You shouldn&#39;t ever have to create one of these yourself since ampersand-router already contains one.</p>
<p>When all of your Routers have been created, and all of the routes are set up properly, call <code>router.history.start()</code> on one of your routers to begin monitoring hashchange events, and dispatching routes. Subsequent calls to <code>history.start()</code> will throw an error, and <code>router.history.started</code> is a boolean value indicating whether it has already been called.</p>
<p>Supported options:</p>
<ul>
<li><strong>pushState</strong> {Boolean} - To indicate that you&#39;d like to use HTML5 pushState support in your application, use <code>Backbone.history.start({pushState: true})</code>. <strong>Defaults to false</strong></li>
<li><strong>hashChange</strong> {Boolean} - If you&#39;d like to use pushState, but have browsers that don&#39;t support it natively use full page refreshes instead, you can add <code>{hashChange: false}</code> to the options. <strong>Defaults to true</strong></li>
<li><strong>root</strong> {String} - If your application is not being served from the root url <code>/</code> of your domain, be sure to tell History where the root really is, as an option: <code>router.history.start({pushState: true, root: &quot;/public/search/&quot;})</code>. <strong>Defaults to <code>/</code></strong></li>
<li><strong>silent</strong> {Boolean} - If the server has already rendered the entire page, and you don&#39;t want the initial route to trigger when starting History, pass <code>silent: true</code>. <strong>Defaults to false</strong></li>
</ul>
<p>When called, if a route succeeds with a match for the current URL, <code>router.history.start()</code> returns <code>true</code>. If no defined route matches the current URL, it returns <code>false</code>.</p>
<p>Because hash-based history in Internet Explorer relies on an <code>&lt;iframe&gt;</code>, be sure to only call <code>start()</code> after the DOM is ready.</p>
<pre><code class="undefinedjavascript">$(function(){
  new WorkspaceRouter();
  new HelpPaneRouter();
  Backbone.history.start({pushState: true});
});
</code></pre>
</div>
        </section>
      </div>
    </div>
    <footer class="footer-main">
      <nav class="nav-footer"><a href="/learn" class="nav-item">Learn</a><a href="/docs" class="nav-item">Docs</a><a href="http://tools.ampersandjs.com" class="nav-item">Find Modules</a><a href="/contribute" class="nav-item">Contribute</a><a href="https://github.com/ampersandjs" class="nav-item">Github</a><a href="https://twitter.com/ampersandjs" class="nav-item">Twitter</a></nav>
      <p>Sponsored by <a href="https://andyet.com">&amp;yet </a><br>with the help of our <a href="/contribute">contributors</a></p><a href="/" class="logo logo-ampersand-gray">&amp;</a>
    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
      
    </script>
    <script src="/static/js/highlight.pack.js"></script>
    <script>
      // init code highlighting
      Array.prototype.forEach.call(document.querySelectorAll('pre'), function (pre) {
        var codeEl = pre.firstChild;
        codeEl.innerHTML = hljs.highlightAuto(codeEl.innerText, ['javascript']).value;
      });
    </script>
  </body>
</html>