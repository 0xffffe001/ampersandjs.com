{
  "source": "ampersand-state",
  "version": "",
  "modules": [
    {
      "textRaw": "ampersand-state",
      "name": "ampersand-state",
      "desc": "<p>An observable, extensible state object with derived watchable properties.\n\n</p>\n<p>Ampersand-state serves as a base object for <a href=\"http://github.com/ampersandjs/ampersand-model\">ampersand-model</a> but is useful any time you want to track complex state.\n\n</p>\n<p><a href=\"https://github.com/ampersandjs/ampersand-model\">ampersand-model</a> extends ampersand-state to include assumptions that you&apos;d want if you&apos;re using models to model date from a REST API. But by itself ampersand-state is useful for anytime you want something to model state, that fires events for changes and lets you define and listen to derived properties.\n\n\n\n</p>\n",
      "modules": [
        {
          "textRaw": "install",
          "name": "install",
          "desc": "<pre><code>npm install ampersand-state</code></pre>\n",
          "type": "module",
          "displayName": "install"
        },
        {
          "textRaw": "In pursuit of the ultimate observable JS object.",
          "name": "in_pursuit_of_the_ultimate_observable_js_object.",
          "desc": "<p>So much of building an application is managing state. Your app needs a single unadulterated <em>source of truth</em>. But in order to fully de-couple it from everything that cares about it, it needs to be observable.\n\n</p>\n<p>Typically that&apos;s done by allowing you to register handlers for when things change.\n\n</p>\n<p>In our case it looks like this:\n\n</p>\n<pre><code class=\"js\">// Require the lib\nvar State = require(&apos;ampersand-state&apos;);\n\n// Create a constructor to represent the state we want to store\nvar Person = State.extend({\n    props: {\n        name: &apos;string&apos;,\n        isDancing: &apos;boolean&apos;\n    }\n});\n\n// Create an instance of our object\nvar person = new Person({name: &apos;henrik&apos;});\n\n// watch it\nperson.on(&apos;change:isDancing&apos;, function () {\n    console.log(&apos;shake it!&apos;); \n});\n\n// set the value and the callback will fire\nperson.isDancing = true;</code></pre>\n",
          "type": "module",
          "displayName": "In pursuit of the ultimate observable JS object."
        },
        {
          "textRaw": "So what?! That's boring.",
          "name": "so_what?!_that's_boring.",
          "desc": "<p>Agreed. Though, there is some more subtle awesomeness in being able to observe changes that are set with a simple assigment: <code>person.isDancing = true</code> as opposed to <code>person.set(&apos;isDancing&apos;, true)</code> (either works, btw), but that&apos;s nothing groundbreaking.\n\n</p>\n<p>So, what else? Well, as it turns out, a <em>huge</em> amount of code that you write in a project is really in describing and tracking relationships between variables.\n\n</p>\n<p>So, what if our observable layer did that for us too?\n\n</p>\n<p>Say you wanted to describe a draggable element on a page so you wanted it to follow a set of a rules. You want it to only be considered to have been dragged if it&apos;s total delta is &gt; 10 pixels.\n\n</p>\n<pre><code class=\"js\">var DraggedElementModel = State.extend({\n    props: {\n        x: &apos;number&apos;,\n        y: &apos;number&apos;\n    },\n    derived: {\n        // the name of our derived property\n        dragged: {\n            // the properties it depends on\n            deps: [&apos;x&apos;, &apos;y&apos;],\n            // how it&apos;s calculated\n            fn: function () {\n                // the distance formula\n                return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) &gt; 10;\n            }\n        }\n    }\n});\n\nvar element = new DraggedElementModel({x: 0, y: 0});\n\n// now we can just watch for changes to &quot;dragged&quot;\nelement.on(&apos;change:dragged&apos;, function (model, val) {\n    if (val) {\n        console.log(&apos;element has moved more than 10px&apos;);\n    } else {\n        console.log(&apos;element has moved less than 10px&apos;);\n    }\n});</code></pre>\n",
          "type": "module",
          "displayName": "So what?! That's boring."
        },
        {
          "textRaw": "You didn't invent derived properties, pal. `</sarcasm>`",
          "name": "you_didn't_invent_derived_properties,_pal._`</sarcasm>`",
          "desc": "<p>True, derived properties aren&apos;t a new idea. But, being able to clearly declare and derive watchable properties from a model is super useful and in our case, they&apos;re just accessed without calling a method. For example, using the draggable example above, the derived property is just <code>element.dragged</code>.\n\n\n</p>\n",
          "type": "module",
          "displayName": "You didn't invent derived properties, pal. `</sarcasm>`"
        },
        {
          "textRaw": "Handling relationships between objects/models with derived properties",
          "name": "handling_relationships_between_objects/models_with_derived_properties",
          "desc": "<p>Say you&apos;ve got an observable that you&apos;re using to model data from a RESTful API. Say that you&apos;ve got a <code>/users</code> endpoint and when fetching a user, the user data includes a groupID that links them to another collection of groups that we&apos;ve already fetched and created models for. From our user model we want to be able to easily access the group model. So, when passed to a template we can just access related group information.\n\n</p>\n<p>Cached, derived properties are perfect for handling this relationship:\n\n</p>\n<pre><code class=\"js\">var UserModel = State.extend({\n    props: {\n        name: &apos;string&apos;,\n        groupId: &apos;string&apos;\n    },\n    derirved: {\n        groupModel: {\n            deps: [&apos;groupId&apos;],\n            fn: function () {\n                // we access our group collection from within \n                // the derived property to grab the right group model.\n                return ourGroupCollection.get(this.groupId);\n            }\n        }\n    }\n});\n\n\nvar user = new UserModel({name: &apos;henrik&apos;, groupId: &apos;2341&apos;});\n\n// now we can get the actual group model like so:\nuser.groupModel;\n\n// As a bonus, it&apos;s even evented so you can listen for changes to the groupModel property.\nuser.on(&apos;change:groupModel&apos;, function (model, newGroupModel) {\n    console.log(&apos;group changed!&apos;, newGroupModel);\n});</code></pre>\n",
          "type": "module",
          "displayName": "Handling relationships between objects/models with derived properties"
        },
        {
          "textRaw": "Cached, derived properties are da shiznit",
          "name": "cached,_derived_properties_are_da_shiznit",
          "desc": "<p>So, say you have a more &quot;expensive&quot; computation for model. Say you&apos;re parsing a long string for URLs and turning them into HTML and then wanting to reference that later. Again, this is built in.\n\n</p>\n<p>By default, derived properties are cached. \n\n</p>\n<pre><code class=\"js\">// assume this linkifies strings\nvar linkify = require(&apos;urlify&apos;);\n\nvar MySmartDescriptionModel = State.extend({\n    // assume this is a long string of text\n    description: &apos;string&apos;,\n    derived: {\n        linkified: {\n            deps: [&apos;description&apos;],\n            fn: function () {\n                return linkify(this.description);\n            }\n        }\n    }\n});\n\nvar myDescription = new MySmartDescriptionModel({\n    description: &quot;Some text with a link. http://twitter.com/henrikjoreteg&quot;\n});\n\n// Now i can just reference this as many times as I want but it \n// will never run it through the expensive function again.\n\nmyDescription.linkified;</code></pre>\n<p>With the model above, the descrition will only be run through that linkifier method once, unless of course the description changes.\n\n\n</p>\n",
          "type": "module",
          "displayName": "Cached, derived properties are da shiznit"
        },
        {
          "textRaw": "Derived properties are intelligently triggered",
          "name": "derived_properties_are_intelligently_triggered",
          "desc": "<p>Just because an underlying property has changed, <em>doesn&apos;t mean the derived property has</em>. \n\n</p>\n<p>Cached derived properties will <em>only</em> trigger a <code>change</code> if the resulting calculated value has changed.\n\n</p>\n<p>This is <em>super</em> useful if you&apos;ve bound a derived property to a DOM property. This ensures that you won&apos;t ever touch the DOM unless the resulting value is <em>actually</em> different. Avoiding unecessary DOM changes is a huge boon for performance.\n\n</p>\n<p>This is also important for cases where you&apos;re dealing with fast changing attributes.\n\n</p>\n<p>Say you&apos;re drawing a realtime graph of tweets from the Twitter firehose, instead of binding your graph to increment with each tweet, if you know your graph only ticks with every thousand tweets you can easily create a property to watch.\n\n</p>\n<pre><code class=\"js\">var MyGraphDataModel = State.extend({\n    props: {\n        numberOfTweets: &apos;number&apos;\n    },\n    derived: {\n        thousandTweets: {\n            deps: [&apos;numberOfTweets&apos;],\n            fn: function () {\n                return Math.floor(this.numberOfTweets / 1000);\n            }\n        }\n    }\n});\n\n// then just watch the property\nvar data = new MyGraphDataModel({numberOfTweets: 555});\n\n// start adding &apos;em\nvar increment = function () {\n    data.number += 1;\n}\nsetInterval(increment, 50);\n\ndata.on(&apos;change:thousandTweets&apos;, function () {\n    // will only get called every time is passes another \n    // thousand tweets.\n});</code></pre>\n",
          "type": "module",
          "displayName": "Derived properties are intelligently triggered"
        },
        {
          "textRaw": "Derived properties don't *have* to be cached.",
          "name": "derived_properties_don't_*have*_to_be_cached.",
          "desc": "<p>Say you want to calculate a value whenever it&apos;s accessed. Sure, you can create a non-cached derived property.\n\n</p>\n<p>If you say <code>cache: false</code> then it will fire a <code>change</code> event anytime any of the <code>deps</code> changes and it will be re-calculated each time its accessed.\n\n\n</p>\n",
          "type": "module",
          "displayName": "Derived properties don't *have* to be cached."
        },
        {
          "textRaw": "State can be extended as many times as you want",
          "name": "state_can_be_extended_as_many_times_as_you_want",
          "desc": "<p>Each state object you define will have and <code>extend</code> method on the constructor.\n\n</p>\n<p>That means you can extend as much as you want and the definitions will get merged.\n\n</p>\n<pre><code class=\"js\">var Person = State.extend({\n    props: {\n        name: &apos;string&apos;\n    },\n    sayHi: function () {\n        return &apos;hi, &apos; + this.name;\n    }\n});\n\nvar AwesomePerson = Person.extend({\n    props: {\n        awesomeness: &apos;number&apos;\n    }\n});\n\n// Now awesome person will have both awesomeness and name properties\nvar awesome = new AwesomePerson({\n    name: &apos;henrik&apos;,\n    awesomeness: 8\n});\n\n// and it will have the methods in the original\nawesome.sayHi(); // returns &apos;hi, henrik&apos;\n\n// *BUT* it doesn&apos;t maintain the prototype chain\n// so instanceof checks will fail up the chain\n\n// so this is true\nawesome instanceof AwesomePerson; // true;\n\n// but this is false\nawesome instanceof Person; // false</code></pre>\n",
          "type": "module",
          "displayName": "State can be extended as many times as you want"
        },
        {
          "textRaw": "Changelog",
          "name": "changelog",
          "type": "module",
          "displayName": "Changelog"
        }
      ],
      "type": "module",
      "displayName": "ampersand-state"
    }
  ]
}