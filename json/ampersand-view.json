{
  "source": "ampersand-view",
  "version": "",
  "modules": [
    {
      "textRaw": "ampersand-view",
      "name": "ampersand-view",
      "desc": "<p>A set of common helpers and conventions for using as a base view for ampersand.js apps.\n\n</p>\n<p>What does it do?\n\n</p>\n<ol>\n<li>Gives you a proven pattern for managing/binding the contents of an element.</li>\n<li>Simple declarative property/template bindings without needing to include a template engine that does it for you. This keeps your logic out of your templates and lets you use a string of HTML as a fully dynamic template or just a simple function that returns an HTML string.</li>\n<li>The view&apos;s base element is replaced (or created) during a render. So, rather than having to specify tag type and attributes in javascript in the view definition you can just include that in your template like everything else.</li>\n<li>A way to render a collection of models within an element in the view, each with their own view, preserving order, and doing proper cleanup when the main view is removed.</li>\n<li>A simple way to render sub-views that get cleaned up when the parent view is removed.</li>\n</ol>\n",
      "modules": [
        {
          "textRaw": "Install",
          "name": "install",
          "desc": "<pre><code>npm install ampersand-view</code></pre>\n",
          "type": "module",
          "displayName": "Install"
        },
        {
          "textRaw": "Usage",
          "name": "usage",
          "modules": [
            {
              "textRaw": "Basics",
              "name": "basics",
              "desc": "<p>Nothing special is required, just use <code>AmpersandView</code> in the same way as you would Backbone.View:\n\n</p>\n<pre><code class=\"javascript\">var MyView = AmpersandView.extend({\n    initialize: function () { ... }, \n    render: function () { ... }\n});</code></pre>\n",
              "type": "module",
              "displayName": "Basics"
            },
            {
              "textRaw": "Declarative Bindings",
              "name": "declarative_bindings",
              "desc": "<pre><code class=\"javascript\">var MyView = AmpersandView.extend({\n    // set a `template` property of your view. This can either be\n    // a function that returns an HTML string or just a string if \n    // no logic is required.\n    template: &apos;&lt;li&gt;&lt;a&gt;&lt;span class=&quot;userName&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&apos;, \n    // Simple declarative bindings\n    // The key is the name of the model property\n    bindings: {\n        // the value is a selector, by default a text binding is assumed\n        // this would keep the model&apos;s `name` attribute in the span, even\n        // if it&apos;s changed.\n        name: &apos;.userName&apos;,\n\n        // If the `active` property is a boolean the class \n        // will be added/removed based on the boolean property.\n        // But, if the `active` property were a string, the previous\n        // value would be removed and the new one added from the class\n        // list without affecting other classes that may alreay be there.\n        active: [&apos;li&apos;, &apos;class&apos;],\n\n        // If you&apos;ve got a boolean property, you can also specify a third\n        // item in the array. It will be used to determine what the class\n        // is that will be toggled. This way your property name can be \n        // different than the class. \n        isActive: [&apos;li&apos;, &apos;class&apos;, &apos;active&apos;], // will toggle the &apos;active&apos; class\n\n        // If you prefer, you *can* also bind to the whole class list. Which\n        // will wipe out all existing classes.\n        myClasses: [&apos;li&apos;, &apos;classList&apos;],\n\n        // As you might have guessed, you can bind to any attribute you want\n        userUrl: [&apos;a&apos;, &apos;href&apos;],\n\n        // This works for boolean attributes. The following would add and remove \n        // the entire `checked` attribute (assuming the property value was a boolean)\n        selected: [&apos;input&apos;, &apos;checked&apos;]\n\n        // If you really need to, you can even bind the same attribute to different\n        // types of things with different options. If &quot;superActive&quot; was a string, the following would put\n        // the text value of it, inside `.userName` and add it as a class on the `li`.\n        superActive: [\n            // the *only* restriction here is that if you pass an array of binding\n            // declarations for a single property, each sub-item must also be an\n            // array.\n            [&apos;.userName&apos;],\n            [&apos;li&apos;, &apos;class&apos;],\n            // you can even get crazy... this would bind both\n            // data attributes to both the li and .username elements\n            [&apos;li, .username&apos;, &apos;data-attribute1 data-attribute2&apos;],\n        ]        \n    },\n    render: function () {\n        // method for rendering the view&apos;s template and binding all\n        // the model properties as described by `textBindings` above.\n        // You can also bind other attributes, and if you&apos;re using\n        // ampersand-model, you can bind derived properties too.\n        this.renderAndBind({what: &apos;some context object for the template&apos;});\n    }\n});</code></pre>\n",
              "type": "module",
              "displayName": "Declarative Bindings"
            },
            {
              "textRaw": "What about two-way bindings?",
              "name": "what_about_two-way_bindings?",
              "desc": "<p>Note that these are all one-way bindings. People love to talk about the feature of two-way bindings, but from my experience, the vast majority of the time it&apos;s not actually something that you want. Why make two different ways of doing the same thing? The most common two-way bindings that people do are for form elements, which, is super easy to do with the events hash. Plus, then it&apos;s very easy to configure exactly when you want the user action to actually change the model.\n\n</p>\n<p>Having said that, we may enable it anyway, in a future release, that&apos;s still up for discussion.\n\n\n</p>\n",
              "type": "module",
              "displayName": "What about two-way bindings?"
            },
            {
              "textRaw": "handling subviews",
              "name": "handling_subviews",
              "desc": "<p>Often you want to render some other subview within a view. The trouble is that when you remove the parent view, you also want to remove all the subviews.\n\n</p>\n<p>AmpersandView has two convenience method for handling this that&apos;s also used by <code>renderCollection</code> to do cleanup.\n\n</p>\n<p>It looks like this:\n\n</p>\n<pre><code class=\"javascript\">var AmpersandView = require(&apos;ampersand-view&apos;);\n\n// This can be *anything* with a `remove` method\n// and an `el` property... such as another ampersand-view\n// instance.\n// But you could very easily write other little custom views\n// that followed the same conventions. Such as custom dialogs, etc.\nvar SubView = require(&apos;./my-sub-view&apos;);\n\nmodule.exports = AmpersandView.extend({\n    render: function () {\n        // this takes a view instance and either an element, or element selector \n        // to draw the view into.\n        this.renderSubview(new Subview(), &apos;.someElementSelector&apos;);\n\n        // There&apos;s an even lower level api that `renderSubview` usees\n        // that will do nothing other than call `remove` on it when\n        // the parent view is removed.\n        this.registerSubview(new Subview());\n    }\n})</code></pre>\n<p><strong>registerSubview also, stores a reference to the parent view on the subview as <code>.parent</code></strong>\n\n\n\n</p>\n",
              "type": "module",
              "displayName": "handling subviews"
            }
          ],
          "type": "module",
          "displayName": "Usage"
        },
        {
          "textRaw": "API Reference",
          "name": "api_reference",
          "desc": "<p>Note that this is a fork of Backbone&apos;s view so most of the public methods/properties here still exist: <a href=\"http://backbonejs.org/#View\">http://backbonejs.org/#View</a>\n\n</p>\n",
          "modules": [
            {
              "textRaw": ".template",
              "name": ".template",
              "desc": "<p>The <code>.template</code> is a property for the view prototype. It should either be a string of HTML or a function that returns a string of HTML. It isn&apos;t required, but it is used as a default for calling <code>renderAndBind</code> and <code>renderWithTemplate</code>.\n\n</p>\n<p>The important thing to note is that the <em>HTML should not have more than one root element</em>. This is because the view code assumes that it has one and only one root element that becomes the <code>.el</code> property of the instantiated view.\n\n</p>\n",
              "type": "module",
              "displayName": ".template"
            },
            {
              "textRaw": ".autoRender",
              "name": ".autorender",
              "desc": "<p>The <code>.autoRender</code> property lets you optionally specify that the view should just automatically render with all the defaults. This requires that you at minimum specify a <a href=\"#template\">template</a> string of function.\n\n</p>\n<p>By setting <code>autoRender: true</code> the view will simply call <code>.renderAndBind</code> for you (after your <code>initialize</code> method if present). So for simple views, if you&apos;ve got a few bindings and a template your whole view could just be really and declarative like this:\n\n\n</p>\n<pre><code class=\"js\">var AmpersandView = require(&apos;ampersand-view&apos;);\n\n\nmodule.exports = AmpersandView.extend({\n    autoRender: true,\n    template: &apos;&lt;div&gt;&lt;span id=&quot;username&quot;&gt;&lt;/span&gt;&lt;/div&gt;&apos;,\n    bindings: {\n        name: &apos;#username&apos;\n    } \n});</code></pre>\n<p><strong>Note:</strong> if you are using a template function (and not a string) the template function will get called with a context argument that looks like this:\n\n</p>\n<pre><code class=\"js\">this.renderAndBind({\n    model: this.model,\n    collection: this.collection\n}, this.template);</code></pre>\n",
              "type": "module",
              "displayName": ".autoRender"
            },
            {
              "textRaw": ".renderCollection(collection, ItemView, containerEl, [viewOptions])",
              "name": ".rendercollection(collection,_itemview,_containerel,_[viewoptions])",
              "desc": "<p>This method will maintain this collection within that container element. Including proper handling of add, remove, sort, reset, etc. \n\n</p>\n<p>Also, when the parent view gets <code>.remove()</code>&apos;ed any event handlers registered by the individual item views will be properly removed as well. \n\n</p>\n<p>Each item view will only be <code>.render()</code>&apos;ed once (unless you change that within the item view itself).\n\n</p>\n<h4>Example:</h4>\n<pre><code class=\"javascript\">// some view for individual items in the collection\nvar ItemView = AmpersandView.extend({ ... });\n\n// the main view\nvar MainView = AmpersandView.extend({\n    template: &apos;&lt;section class=&quot;page&quot;&gt;&lt;ul class=&quot;itemContainer&quot;&gt;&lt;/ul&gt;&lt;/section&gt;&apos;,\n    render: function (opts) {\n        // render our template as usual\n        this.renderAndBind();\n\n        // call renderCollection with these arguments:\n        // 1. collection\n        // 2. which view to use for each item in the list\n        // 3. which element within this view to use as the container\n        // 4. options object (not required):\n        //      {\n        //          // function used to determine if model should be included\n        //          filter: function (model) {},\n        //          // boolean to specify reverse rendering order\n        //          reverse: false,\n        //          // view options object (just gets passed to item view&apos;s `initialize` method)\n        //          viewOptions: {}\n        //      }\n        this.renderCollection(this.collection, ItemView, this.$(&apos;.itemContainer&apos;)[0], opts);\n        return this;\n    }  \n})</code></pre>\n",
              "type": "module",
              "displayName": ".renderCollection(collection, ItemView, containerEl, [viewOptions])"
            },
            {
              "textRaw": ".registerSubview(viewInstance)",
              "name": ".registerSubview(viewInstance)",
              "desc": "<p>This method is just sugar for the common use case of instantiating a view and putting in an element within the parent.\n\n</p>\n<p>It will:\n\n</p>\n<ol>\n<li>fetch your container (if you gave it a selector string)</li>\n<li>register your subview so it gets cleaned up if parent is removed and so <code>view.parent</code> will be available when your subview&apos;s <code>render</code> method gets called</li>\n<li>call the subview&apos;s <code>render()</code> method</li>\n<li>append it to the container</li>\n<li>return the subview</li>\n</ol>\n<h4>Example:</h4>\n<pre><code class=\"js\">var view = AmpersandView.extend({\n    template: &apos;&lt;li&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/li&gt;&apos;,\n    render: function () {\n        this.renderAndBind();\n\n        ...\n\n        var model = this.model;\n        this.renderSubview(new SubView({\n            model: model\n        }), &apos;.container&apos;);\n\n        ... \n\n    } \n});</code></pre>\n",
              "type": "module",
              "displayName": ".renderSubview(viewInstance, containerEl)"
            },
            {
              "textRaw": ".renderSubview(viewInstance, containerEl)",
              "name": ".rendersubview(viewinstance,_containerel)",
              "desc": "<p>This method is just sugar for the common use case of instantiating a view and putting in an element within the parent.\n\n</p>\n<p>It will:\n\n</p>\n<ol>\n<li>fetch your container (if you gave it a selector string)</li>\n<li>register your subview so it gets cleaned up if parent is removed and so <code>view.parent</code> will be available when your subview&apos;s <code>render</code> method gets called</li>\n<li>call the subview&apos;s <code>render()</code> method</li>\n<li>append it to the container</li>\n<li>return the subview</li>\n</ol>\n<h4>Example:</h4>\n<pre><code class=\"js\">var view = AmpersandView.extend({\n    template: &apos;&lt;li&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/li&gt;&apos;,\n    render: function () {\n        this.renderAndBind();\n\n        ...\n\n        var model = this.model;\n        this.renderSubview(new SubView({\n            model: model\n        }), &apos;.container&apos;);\n\n        ... \n\n    } \n});</code></pre>\n",
              "type": "module",
              "displayName": ".renderSubview(viewInstance, containerEl)"
            },
            {
              "textRaw": ".renderAndBind([context], [template])",
              "name": ".renderandbind([context],_[template])",
              "desc": "<p>This is shortcut for the default rendering you&apos;re going to do in most every render method, which is: use the template property of the view to replace <code>this.el</code> of the view and re-register all handlers from the event hash and any other binding as described above.\n\n</p>\n<h4>Example:</h4>\n<pre><code class=\"js\">var view = AmpersandView.extend({\n    template: &apos;&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;&apos;,\n    bindings: {\n        &apos;name&apos;: &apos;a&apos;\n    },\n    events: {\n        &apos;click a&apos;: &apos;handleLinkClick&apos;\n    },\n    render: function () {\n        // this does everything\n        // 1. renders template\n        // 2. registers delegated click handler\n        // 3. inserts and binds the &apos;name&apos; property\n        //    of the view&apos;s `this.model` to the &lt;a&gt; tag.\n        this.renderAndBind();\n    }\n});</code></pre>\n",
              "type": "module",
              "displayName": ".renderAndBind([context], [template])"
            },
            {
              "textRaw": ".renderWithTemplate([context], [template])",
              "name": ".renderwithtemplate([context],_[template])",
              "desc": "<p>This is shortcut for doing everything we need to do to render and fully replace current root element with the template that our view is wanting to render. In typical backbone view approaches you never replace the root element. But from our experience, it&apos;s nice to see the <em>entire</em> html structure represented by that view in the template code. Otherwise you end up with a lot of wrapper elements in your DOM tree.\n\n</p>\n",
              "type": "module",
              "displayName": ".renderWithTemplate([context], [template])"
            },
            {
              "textRaw": ".getByRole(name)",
              "name": ".getbyrole(name)",
              "desc": "<p>This is for convenience and also to encourage the use of the <code>role</code> attribute for grabbing elements from the view. Using roles to select elements in your view makes it much less likely that designers and JS devs accidentally break each other&apos;s code. This will work even if the <code>role</code> attribute is on the view&apos;s root <code>el</code>.\n\n</p>\n<h4>Example:</h4>\n<pre><code class=\"js\">var view = AmpersandView.extend({\n    template: &apos;&lt;li&gt;&lt;img role=&quot;avatar&quot; src=&quot;/user.png&quot;/&gt;&lt;/li&gt;&apos;,\n    render: function () {\n        this.renderAndBind();\n\n        // cache an element for easy reference by other methods\n        this.imgEl = this.getByRole(&apos;avatar&apos;);\n    } \n});</code></pre>\n",
              "type": "module",
              "displayName": ".getByRole(name)"
            }
          ],
          "type": "module",
          "displayName": "API Reference"
        },
        {
          "textRaw": "Changelog",
          "name": "changelog",
          "type": "module",
          "displayName": "Changelog"
        }
      ],
      "type": "module",
      "displayName": "ampersand-view"
    }
  ]
}