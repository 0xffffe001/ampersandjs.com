<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Ampersand.js, Javascript, ampersand, Node.js, Apps, HTML5">
    <meta name="author" content="Henrik Joreteg, Luke Karrys, Lance Stout, Philip Roberts, Isaac Lewis, Michael (Gar) Garvin">
    <link rel="stylesheet" href="static/css/plugins/normalize.css">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Ampersand.js Documentation </title>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
      
    </script>
  </head>
  <body>
    <header role="banner" class="cf">
      <h1 class="logo">ampersand.js</h1>
    </header>
    <div class="container">
      <nav role="navigation">
        <div class="panel">
          <h4>Warning</h4>
          <p>These docs are incomplete and still being written.</p><a href="https://github.com/AmpersandJS/ampersandjs.com" class="button button-secondary button-small">Help make them better</a>
        </div>
        <div id="slider"></div>
      </nav>
      <main role="main">
        <section><h2>Introduction</h2>
<p>Ampersand.js is a highly modular, loosely coupled, non-frameworky framework for building complex JavaScript apps.

</p>
<p>We call it Ampersand because it’s not a monolothic framework but a well-defined approach for combining (get it?) a series of tiny modules.


</p>
<h3>Post-Backbone</h3>
<p>We love Backbone.js at <a href="http://andyet.com">&amp;yet</a>. It’s brilliantly simple code and it solves many common problems in developing clientside applications with proper separation of concerns. It’s been praised for its flexibility and modularity. The fact that Backbone’s author <a href="http://twitter.com/jashkenas">Jeremy Ashkenas</a> and his fellow maintainers haven’t tried to solve <em>every</em> problem has kept it usable for a broad range of application types. Its effectiveness is evidenced by its incredible popularity.

</p>
<p>We built our first app on Backbone 0.3.1 and have been a user/supporter of the project for quite some time and was honored to have spoken at the first BackboneConf.

</p>
<p>Shortly after discovering Backbone, we also got into node.js which brought with it a module approach and eventually an awesome way of managing dependencies that we&apos;ve have fallen deeply in like with: <a href="https://npmjs.org">npm</a>.

</p>
<p>Nothing has done more for our team’s ability to write clean, maintainable clientside applications than having a really awesome dependency management system and <a href="http://twitter.com/substack">substack’s</a> <a href="http://browserify.org/">browserify</a> that allows us to quickly declare/install external dependencies and know that things will Just Work™.

</p>
<p>npm has also been the catalyst that enables what has been referred to as the &quot;tiny modules movement&quot;, the basic philosophy of which is that no matter how small or insignificant the problem, you shouldn’t have to solve it more than once. 

</p>
<p>By giving a module narrow scope and functionality you can actually maintain it without going insane. Also, knowing about and fixing gotchas in a single location means that all modules depending on it also benefit.

</p>
<p>After getting addicted to this way of working, many developers, ourselves included, have developed an allergic reaction to libraries and plugins that <em>don’t</em> work that way. Unfortunately, despite its lightweight, flexible approach, Backbone itself doesn’t follow that pattern.

</p>
<p>&quot;What? I thought you said Backbone was flexible and modular?&quot;

</p>
<p>Sort of, but only to a point. 

</p>
<p>For example, one of the problems we’ve had at <a href="http://andyet.com">&amp;yet</a> especially when working on large Backbone applications is a sane way to document the type of properties a model is supposed to contain.

</p>
<p>Backbone models, by default, don’t enforce any structure. You don’t have to declare anywhere what properties you’re going to store. As a result, people inevitably start saving miscellaneous properties on models from within a view somewhere, and there’s no good way for a new dev starting in on the project to be able to read the models and see exactly what state is being tracked. 

</p>
<p>To solve this problem and to enforce additional structure, <a href="http://twitter.com/henrikjoreteg">Henrik</a> wrote a replacement model called &quot;HumanModel&quot; that is consistent with the philosophy explored in depth in the book <a href="http://humanjavascript.com">Human JavaScript</a>. This model, which has now morphed into <a href="https://github.com/ampersandjs/ampersand-model">ampersand-model</a>, forces you to declare the properties you’re going to store, and also allows you to declare derived properties, etc.

</p>
<p>The original idea was that we’d use those in Backbone Collections, but we started running into problems. Backbone assumes that you’re storing Backbone.Model models in collections. So when adding an instantiated model to a collection, Backbone fails to realize that it’s already a model. This meant that we had to monkey patch an internal method (_prepareModel) in Backbone.Collections if we’re going to use special models. Not a huge deal, but it popped up enough times that it was annoying. 

</p>
<p>Also, at times we wanted RESTful collections where data was coming from APIs, but other times, we just wanted something <em>like</em> a Backbone collection/model system for managing state in another module, that perhaps had nothing to do with getting data from a REST API. Also, we didn’t want to make all of Backbone a dependency just to get evented models.

</p>
<p>Over time, in spending more time and building <em>a ton</em> of apps with it, for clients and for ourselves, we’ve become increasingly frustrated by the coupling/bundling of Backbone.

</p>
<p>So we started ripping things apart into their own independently published, managed, and versioned modules. 

</p>
<p>Thus, ampersand.js was born.

</p>
<p>Ampersand splits things apart as much as possible. For example, <a href="https://github.com/ampersandjs/ampersand-collection">ampersand-collection</a> makes no assumptions about how you’re going to put data into it, what types of objects you’re going to store, or what indexes you’re going to want to use to retrieve them. It follows the tiny module pattern.

</p>
<p>But, what if you want that stuff? 

</p>
<p>Well, that’s easy. We just have another tiny module. 

</p>
<p>You could of course do whatever &quot;BaseCollection&quot; in your app that added whatever common methods you were expecting to use, or just start with <a href="https://github.com/ampersandjs/ampersand-rest-collection">ampersand-rest-collection</a> instead and you’ve basically got Backbone.Collection-type functionality.

</p>
<p>You see the exact same pattern in <a href="https://github.com/ampersandjs/ampersand-state">ampersand-state</a> and <a href="https://github.com/ampersandjs/ampersand-model">ampersand-model</a>. &quot;state&quot; is the base object that &quot;model&quot; is built on. But model goes the additional step of including the RESTful patterns.

</p>
<h3>So what exactly is ampersand.js? What makes it unique?</h3>
<p>In starting to toy with the concept of building out these tools, we wrote a few guiding principles, some of which we’ll no doubt get some flack for. Here they are:

</p>
<h4>1. Everything is a CommonJS module</h4>
<p>No AMD, UMD, ES6 modules, or bundling of any kind is included by default. The clarity, simplicity, and flexibility of CommonJS just won. Clear dependencies, no unnecessary wrapping/indenting, no extra cruft. Just a clearly declared set of dependencies in package.json. 

</p>
<p>Any sort of bundling for any other module system is easy enough to do with any number of tools like grunt or gulp.

</p>
<h4>2. Everything is installed via npm</h4>
<p>This isn’t a diss toward the other package management approaches, it’s just a choice to maximize simplicity. See point #1.

</p>
<h4>3. Modern browsers by default</h4>
<p>We’re unapologetically supporting only IE9+. There are many features of ES5 that enable dramatic simplifications of code that simply were not present in IE before IE9. For reference, check out <a href="http://kangax.github.io/es5-compat-table/">kangax’s ES5 compatibility table</a>. Not having to shim each and every feature and completely avoiding non-shimmable ones saves you so many headaches that we decided to just draw that line. Bring the haters :) 

</p>
<p>But again, remember this isn’t an all-or-nothing &quot;framework&quot;. In fact, very arguably it’s not a framework at all. There are pieces here that don’t require IE9 and others that could be converted to solve those problems if they matter to you. It’s just a line we chose to draw in the sand so we could focus our efforts on building for the web’s future instead of its past.

</p>
<h4>4. Strict semver all the things</h4>
<p>If you’re unfamiliar with semver, <a href="http://semver.org/">the homepage</a> summarizes it in about three sentences. In short, it’s a strict adherence to a versioning scheme for modules that, if followed, allows you to trust minor and patch version updates to not break your code. So, for a dependency you can specify a version like this: &quot;1.x.x&quot; and know that your code will not break if the underlying dependency is upgraded from 1.1.0 to 1.2.8 because the versioning scheme prohibits breaking changes without bumping the major version number. 

</p>
<p>This flexibility is very important in clientside code because we don’t want to send 5 different versions of the same dependency to the browser. Loosely declaring dependencies of the building blocks and strictly declaring them in your app’s main package.json can help you avoid a lot of these problems. With the way npm manages dependencies, with this approach, we get minimal duplication of shared dependencies.

</p>
<h4>5. Tiny module all the things!</h4>
<p>The smaller the feature set of the low-level modules, the easier it is to avoid breaking changes. Higher-level modules should still exist, but, should primarily be pulling together small modules in a way that makes them more usable. For example: <a href="https://github.com/ampersandjs/ampersand-rest-collection">ampersand-rest-collection</a>, <a href="https://github.com/component/events">component’s &quot;events&quot; module</a>, or <a href="https://github.com/component/classes">component’s &quot;classes&quot; module</a>.

</p>
<h4>6. Expose the simplest API possible.</h4>
<p>Simplicity is a core value. If you don’t actively fight for simplicity in software, complexity will win, and it will suck. This means things like pruning unneeded features and giving everything descriptive names even if they’re longer. That’s what minification is for. We are not compilers, so we should optimize for readability and use tools for optimizations.

</p>
<p>While this is going to be a bit controversial, for us the focus on simplicity also means avoiding using promises. There are enough things that are new and intimidating to those building clientside apps. Adding promises makes for an unnecessarily tall cognitive leap. 

</p>
<p>Not that promises are bad, but the truth is there isn’t as much need for complex flow-control for most clientside things. Most of the cases where you may feel a need for promises are for managing multiple asynchronous operations. While this can be needed in clientside code, it’s far less prominent than in server code. 

</p>
<p>And, if you want to use promises it’d be easy enough to write a version of &quot;ampersand-sync&quot; or &quot;ampersand-router&quot; that used &quot;bluebird&quot; or another promise library and slip that into your app. That’s the whole point of the modularity concept and still, you only include what you ultimately are using!

</p>
<h4>7. Optimize for minimal DOM manipulation and performance.</h4>
<p>It should be easy to create rich user experiences. 

</p>
<p>There’s a lot of buzz and talk around rendering performance for JS apps. Mostly the answer to these types of performance issues is: &quot;Don’t touch the DOM any more than you have to&quot;. 

</p>
<p>That’s one of the core premises of libraries like Facebook’s React:  only performing minimal changes and batching those changes into RAF loops. 

</p>
<p>In canonical Backbone apps you often re-render the contents of a view if the related model or models change. But, if you’re trying to do things like smooth dragging and dropping you don’t want to re-render contents of a view each time properties change. Or even if you’re using CSS3 transitions, re-rendering a section of the DOM and adding a class won’t ever trigger the CSS3 transition, because it wasn’t actually transitioned, it was just replaced with another piece of DOM that had that class. So, pretty soon in those scenarios you find yourself writing a bunch of &quot;glue code&quot; to bind things to the DOM and only perform minimal edits. 

</p>
<p>The point is, there are valid uses of both approaches. So the goal with <a href="https://github.com/ampersandjs/ampersand-view">ampersand-view</a> is a simple way to declare your bindings in your view code. Check out the <a href="https://github.com/ampersandjs/ampersand-view#declarative-bindings">declarative bindings section</a> of the README on that project. You can also just mix and match. In certain cases it may be easier to re-render everything, but declaring very specific binding behavior is also simple. It gives you ultimate control. Modularity FTW!

</p>
<h4>8. Mobile is in the DNA</h4>
<p>Think small and light. Optimize and build tools for touch interfaces.  Help build the web as the go-to platform for mobile. (You can expect more to be released here in the future toward this end.)

</p>
<h4>9. Unapologetically designed for rich &quot;app&quot; experiences.</h4>
<p>These ain’t no websites, pal. If you’re building content sites or sites you want thoroughly crawled this is not the tool for you. 

</p>
<p>This is for clientside javascript applications where the browser is treated as a runtime, not as a document viewer. For more on that, you can read about how we believe <a href="https://blog.andyet.com/2014/01/17/web-has-outgrown-the-browser">the web has outgrown the browser</a>.

</p>
<h4>10. Embrace offline-first mentality and ServiceWorker all the things as soon as we can.</h4>
<p>Yup. These are apps, they should compete with native apps. The thing that’s missing for web to <em>truly</em> be a viable alternative to native apps is good tools for building offline web apps. Again, for more on that <a href="https://blog.andyet.com/2014/01/17/web-has-outgrown-the-browser">read the post mentioned above</a>.

</p>
<h4>11. Everything is MIT licensed</h4>
<p>Software licensing can suck. Especially when trying to manage licenses of dependencies for a large enterprise project. Picking MIT for all of this stuff simplifies things as much as we can.

</p>
<h4>12. Love the developer</h4>
<p>Don’t ignore developer workflow! We’ve got a few nice things in the scaffolding apps that let you simply flip a &quot;developmentMode&quot; boolean to put your app into a live-reloaded, unminified mode or conversely into a production mode (more below).

</p>
<h3>The problems with tiny modules</h3>
<p>It’s not a silver bullet. One of the biggest challenges for the &quot;tiny module approach&quot; is knowing which tiny modules exist and which ones to use. This can be quite daunting for someone who’s used to grabbing a few jQuery plugins and is new to all of this. 

</p>
<p>Most of the tiny modules are, well... tiny. These are small pieces of code, not heavily marketed because they’re not necessarily the pride and joy of the developer. Many of them are rather boring and don’t do very much, plus they’re infrequently updated and often they even look unmaintained because frankly, they represent a solved problem that doesn’t need to be re-solved!

</p>
<p>Seriously, finding modules is such a problem, we sometimes we even forget about our own modules sometimes!

</p>
<p><em>This can make it incredibly hard to get started and this is where frameworks really shine.</em>

</p>
<p>So, we’re doing a couple of things to solve that problem for ourselves and others building ampersand.js apps.

</p>
<ol>
<li><p><a href="https://github.com/ampersandjs/ampersand">the ampersand cli</a> is a scaffolding tool. It helps you build out a fully working starter app including a hapi or express node server to serve your application. It includes patterns and approaches that we use at <a href="http://andyet.com">&amp;yet</a> for structuring and serving single page apps which we’ve defined in <a href="http://humanjavascript.com">Human JavaScript</a>.</p>
</li>
<li><p>The tools site: <a href="http://tools.ampersandjs.com">tools.ampersandjs.com</a>. This is a site with quick-searchable, hand-picked tools for building ampersand-style apps. A grab bag of &quot;solved problems&quot; for single page apps, if you will. In addition it updates its url as you search so it’s deep linkable. For example, if you’re looking to do WebRTC stuff: <a href="http://ampersandjs.github.io/tools.ampersandjs.com/?q=webrtc"><a href="http://ampersandjs.github.io/tools.ampersandjs.com/?q=webrtc">http://ampersandjs.github.io/tools.ampersandjs.com/?q=webrtc</a></a></p>
</li>
<li><p>If you’re looking for deeper explanations of the philosophy and approaches used in the generated app, it is described in a lot more detail in Henrik&apos;s book <a href="http://humanjavascript.com">Human JavaScript</a>.</p>
</li>
</ol>
<h3>Massive props to Jeremy Ashkenas and the rest of the Backbone.js authors</h3>
<p>Many of the individual modules contain copy-and-pasted code from Backbone.js.

</p>
<p>We’re incredibly grateful for Jeremy’s work and for the generous MIT licensing that made ampersand possible.

</p>
<h3>The future</h3>
<p>There’s still a lot to do. 

</p>
<p>Now that we’ve removed our dependency on backbone we’re free to edit other things in &quot;core&quot; that we’ve had alternate ideas about. 

</p>
<p>And, with the freedom that comes with the tiny modules approach, it’s easier to do a lot more exploration without having to change core items. There are a few modules coming down the line already for adding declarative sub-collections to collections, <a href="http://github.com/henrikjoreteg/bind-transforms">binding CSS transforms to calculated/derived properties</a>, <a href="https://github.com/henrikjoreteg/fingertips">direct touch-event handling</a> and a lot more.

</p>
<p>We’d encourage you to get involved. 

</p>
<p>For simplicity all the &quot;core&quot; stuff is on github as its own organization: <a href="https://github.com/ampersandjs"><a href="https://github.com/ampersandjs">https://github.com/ampersandjs</a></a>.

</p>
<p>Send pull requests, file issues, and tell us that we’re crazy on twitter: <a href="http://twitter.com/henrikjoreteg">@HenrikJoreteg</a>, <a href="http://twitter.com/lukekarrys">@lukekarrys</a>, <a href="https://twitter.com/philip_roberts">@philip_roberts</a>, <a href="http://twitter.com/wraithgar">@wraithgar</a>, <a href="https://twitter.com/aaronmccall">@aaronmccall</a>. 

</p>
<p>For more cool stuff, follow the whole <a href="http://twitter.com/andyet">@andyet</a> team and stay tuned for more info on our upcoming JS training: <a href="http://jsforteams.com/">JS For Teams</a>.
</p>
</section>
        <section>
          <h2>Quick Start Guide</h2>
          <ol>
            <li><a href="http://nodejs.org/">install node.js</a></li>
            <li>install ampersand &mdash; <code>$ npm install ampersand -g</code></li>
            <li>run <code>ampersand</code> to create your new app folder, build your project scaffolding, and run your app.
              <pre><code>$ ampersand</code></pre>
            </li>
            <li>open your browser to: <code>http://localhost:3000</code></li>
            <li>that's it!</li>
          </ol>
          <h3>What's included?</h3>
          <ul>
            <li>Well-architected shell of a single page app to serve as a starting point for your app.</li>
            <li>A solution for using jade templates and templatizer to pre-compile client templates.</li>
            <li>A fully functional development environment that will watch for changes. You just modify and refresh (without manual build steps).</li>
            <li>Changing one flag in your config puts it in production mode which builds and serves minfied, uniquely named, and permanently cachable static files.</li>
            <li>A clientside routing system using HTML5 pushState.</li>
            <li>A main layout template is rendered by the main view that includes a page container where page views are rendered as the user navigates to different URLs in the app.</li>
            <li>An example of rendering a collection of models in a container.</li>
            <li>A mock REST API to demonstrate how you might talk to an API to fetch data.</li>
            <li>A solution for declaritive binding of model properties to views, that is <em>completely </em>decoupled from the template engine. See human-view below for more details.</li>
            <li>A solution for creating readable, type-checked, and very explicitly defined models. This is hugely important in team enviroments where you need somewhere to reference what is being stored on your models. See human-model for more detail. </li>
          </ul>
        </section>
        <section>
          <h2 data-nav="The Book">Human JavaScript book</h2>
          <p>A 100+ page e-book providing additional context, explanations and philosophy behind the tools documented here <a href="http://humanjavascript.com">is available for $39</a>.</p>
          <p><a href="http://humanjavascript.com" class="image-wrapper humanjs"><img src="static/images/human-javascript.png" width="200" alt="human javascript ebook"></a></p>
          <div class="include"><h2>ampersand-model</h2>
<p>ampersand-model helps you create observable models for your apps. Most commonly in clientside frameworks, your models are what hold data fetched from your API. But really, it&apos;s all about having a way to separate concerns. Your models should be your authoritive &quot;source of truth&quot; when it comes to all state held in your application.

</p>
<p>ampersand-model takes what backbone models do a step further by forcing you to explicitly define what the model is going to store so that the model code can end up being self-documenting in that you can now simply look at the model code and see what they&apos;re expected to store.

</p>
<p>This is hugely important for enabling teams to work on the same app together. There&apos;s also a few extra goodies, like direct accessors (not having to use <code>.set()</code> and <code>.get()</code>), and intelligently evented dervied properties.



</p>
<h3>Installing</h3>
<p>via npm:

</p>
<pre><code>npm install ampersand-model</code></pre>
<p>via bower: 

</p>
<pre><code>bower install ampersand-model</code></pre>
<h3>Browser compatibility</h3>
<p><a href="https://ci.testling.com/ampersandjs/ampersand-model"><img src="https://ci.testling.com/ampersandjs/ampersand-model.png" alt="testling badge"></a>


</p>
<h3>Types of state</h3>
<p>Take for instance a <code>selected</code> property on a model. That&apos;s likely something you would use to represent current UI state for the current browser session but not something you&apos;d want to save back to the API when calling a model&apos;s .save() method. So there really are two types of state. It&apos;s challenging to make that type of distinction with Backbone.

</p>
<p>ampersand-model supports three types of state that will get stored on a model: 

</p>
<ul>
<li><strong>properties</strong>: State that comes from (and will be sent back to) our API and represents the data persisted on the server.</li>
<li><strong>session properties</strong>: State that represents current browser session state. </li>
<li><strong>derived properties</strong>: These are read-only psuedo properties that are usually derived from properties or session properties. These are generally created for convenince or as a means to let you cache a computed result (read more below).</li>
</ul>
<p>In ampersand model you have to classify all your properties as either <code>prop</code> or a <code>session</code>. That includes declaring your <code>id</code> property. How ampersand-model handles properties that you have not pre-defined is determined by its <code>extraProperties</code> setting. But, by default properties that are <code>.set()</code> on a model that you have not defined are simply ignored.


</p>
<h3>Handling model relationships</h3>
<p>From our experience, derived properties work really well for handling relationships between models. Let&apos;s say you&apos;ve got a model representing people and model representing a group of people. Often your API for fetching people would include something like a groupID as a property for each person you retrieve.


</p>
<h3>Why do this?</h3>
<p>Backbone models have a lot of flexibility in that you don&apos;t have to define what you&apos;re wanting to store ahead of time. 

</p>
<p>The only challenge with that is that for more complex applications is actually becomes quite difficult to remember what properties are available to you.

</p>
<p>Using ampersand models means they&apos;re much more self-documenting and help catch bugs. Someone new to the project can read the models and have a pretty good idea of how the app is put together.

</p>
<p>It also uses&apos;s ES5&apos;s fancy <code>Object.defineProperty</code> to treat model attributes as if they were properties.

</p>
<p>That means with Ampersand Model you can set an attribute like this: <code>user.name = &apos;henrik&apos;</code> and still get a <code>change:name</code> event fired. 

</p>
<p>Obviously, this restriction also means that this won&apos;t work in browsers that don&apos;t support that. You can check specific browser support here: <a href="http://kangax.github.io/es5-compat-table/">http://kangax.github.io/es5-compat-table/</a>


</p>
<h3>Explicit model definitions</h3>
<p>Schema definitions take an attribute called <code>props</code> to defined properties.

</p>
<p>Property names can be defined two different ways, either an array with <code>[type, required, default]</code>,
or an object: <code>{ type: &apos;string&apos;, required: true, default: &apos;&apos; , allowNull: false}</code>

</p>
<p>types can be: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>array</code>, <code>object</code>, or <code>date</code>
required: true, false (optional)
default: any (optional)
setOnce: true, false (optional)
test: function (optional)
allowNull: true, false (optional)
values: <code>[&apos;some&apos;, &apos;valid&apos;, &apos;values&apos;]</code>(optional) 

</p>
<p>Note that when defining with an array <code>type</code>, <code>required</code>, and <code>default</code>
are the only property attributes you can set.

</p>
<p>If <code>required</code> is true, the attribute will always have a value even if it is not explicitly set or is cleared.  If a default is given, that will be used.  If no default is given a default for its data type will be used (e.g. &apos;&apos; for string, {} for object)

</p>
<p>If a <code>default</code> is given, the attribute will default to that value when the model is instantiated.

</p>
<p>If <code>setOnce</code> is true, the attribute will throw an error if anything tries to set its value more than once.

</p>
<p>If <code>values</code> is provided, you can only set that property to a value in the list. You can use this in combination with <code>type</code> to check both, or just use <code>values</code> and <code>default</code> by themselves. This is handy for <code>enum</code>-type stuff. For example:

</p>
<pre><code class="js">props: {
    alignment: {
        values: [&apos;top&apos;, &apos;middle&apos;, &apos;bottom&apos;],
        default: &apos;middle&apos;
    }
}</code></pre>
<p>If given, <code>test</code> should be a function that expects the new value (and optionally the new type) of the attribute.  It should return an error message on failure, and false on success

</p>
<pre><code class="js">props: {
    firstName: [&apos;string&apos;, true, &apos;Jim&apos;]
    lastName: {
        type: &apos;string&apos;, 
        required: false, 
        default: &apos;Bob&apos; 
    }
}</code></pre>
<h3>A sample model with comments</h3>
<pre><code class="js">var Person = AmpersandModel.extend({
    // every ampersand model should have a type
    type: &apos;member&apos;,
    initialize: function () {
        // main initialization function
    },
    // props are for properties that exist on the server
    props: {
        id: {
            type: &apos;number&apos;,
            setOnce: true
        },
        firstName: [&apos;string&apos;, true],
        lastName: [&apos;string&apos;, true],
        created: [&apos;date&apos;],
        email: [&apos;string&apos;, true],
        username: [&apos;string&apos;, true],
        lastLogin: [&apos;date&apos;],
        largePicUrl: [&apos;string&apos;],
        department: {
            type: &apos;number&apos;,
            // you can optionally provide your own test function
            test: function (val) {
                if (val &gt; 20) {
                    return &quot;Invalid department&quot;;
                }
            }
        },
        alignment: {
            // you can also specify a list of valid values
            values: [&apos;top&apos;, &apos;middle&apos;, &apos;bottom&apos;],
            default: &apos;middle&apos;
        }
    },
    // derived properties and their dependencies. If any dependency changes
    // that will also trigger a &apos;change&apos; event on the derived property so
    // we know to re-render the template
    derived: {
        // fullName is 
        fullName: {
            // you can optionally define the properties this derived property
            // depends on. That way if the underlying properties change you can
            // listen for changes directly on the derived property.
            deps: [&apos;firstName&apos;, &apos;lastName&apos;],
            fn: function () {
                return this.firstName + &apos; &apos; + this.lastName;
            }
        }
    },
    // Session properties are browser state for a model
    // these trigger &apos;change&apos; events when set, but are not
    // included when serializing or saving to server.
    session: {
        selectedTasks: [&apos;array&apos;, true, []],
        lastPage: [&apos;string&apos;, true, &apos;tasks&apos;],
        unread: [&apos;boolean&apos;, true, false],
        active: [&apos;boolean&apos;, true, false]
    },
    // child collections that will be initted. They will
    // be created at as a property of the same name as the
    // key. The child collection will also be given a reference
    // to its parent.
    collections: {
        messages: Messages
    },
    otherMethods: function (cb) {
        // of course you can tack on whatever other methods you want
    }
});</code></pre>
<h3>Going hardcore &quot;strict&quot; definition</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode">Strict mode</a> in JS is pretty great and is fairly well supported in modern browsers.

</p>
<p>If you want to be <em>really</em> hardcore about not letting you set properties that aren&apos;t defined, you can specify <code>seal: true</code> when defining your model.

</p>
<pre><code class="js">// enable strict mode
&quot;use strict&quot;;

var MySuperStrictModel = AmpersandModel.extend({
    // set this to true
    seal: true,
    // also throw errors for properties not defined
    // when set via `set`.
    extraProperties: &apos;reject&apos;,
    // normal properties
    props: {
        name: &apos;string&apos;
    }
});

// create an instance of this model
var model = new MySuperStrictModel();

// setting defined properties works like usual
model.name = &apos;something&apos;;

// BUT, setting a property that doesn&apos;t exist
// will throw an error because the object is sealed.
model.something = &apos;something else&apos;; // KABOOM!</code></pre>
<h3>Setting model attributes</h3>
<pre><code class="js">// backbone:
user.set(&apos;firstName&apos;, &apos;billy bob&apos;);

// ampersand:
user.firstName = &apos;billy bob&apos;;

// p.s. you can still do it the other way in ampersand (so you can still pass options)
user.set(&apos;firstName&apos;, &apos;billy bob&apos;, {silent: true})</code></pre>
<h3>Getting model attributes</h3>
<pre><code class="js">// backbone:
user.get(&apos;firstName&apos;);

// ampersand
user.firstName;</code></pre>
<h3>Running the tests</h3>
<pre><code>npm test</code></pre>
<p><em>note</em>: Much of the functionality of ampersand-model is actually inherited from <a href="https://github.com/ampersandjs/ampersand-state">ampersand-state</a> and is tested seperately there. In order to ensure compatibility with backbone to the extent possible we started with all the tests from Backbone and modified them to use ampersand-model. But over time they&apos;ve been spread out and converted to be run with <a href="https://github.com/substack/tape">tape</a> so we can automatically test against many browser versions with testling.


</p>
<h3>Module: ampersand-model</h3>
<p>The module exports just one item, the ampersand-model constructor. It&apos;s has a method called <code>extend</code> that works as follows:

</p>
<h4>.extend(modelDefinition)</h4>
<div class="signature"><ul>
<li>Returns: <span class="type">Constructor</span> A custom constructor for generating instances of the model you defined.</li>
<li><code>modelDefinition</code> <span class="type">Object</span> An object containing your entire model definition<ul>
<li><code>props</code> <span class="type">Object</span> An object of named property definitions</li>
<li><code>session</code> <span class="type">Object</span> An object of named session property definitions</li>
<li><code>derived</code> <span class="type">Object</span> An object of named derived property definitions<ul>
<li><code>derivedDefinition</code> <span class="type">Object | Function</span> This can either be a single function or an object describing the derived property and its dependencies.<ul>
<li><code>deps</code> <span class="type">Array</span> An array containing strings of other property names or derived property names. When these change, the derived property is re-calculated and only if different than previous cached value, a <code>change</code> event is fired for the derived property.</li>
<li><code>fn</code> <span class="type">Function</span> A function that returns the value of the derived property. This function&apos;s <code>this</code> will be the model instance.</li>
<li><code>cache</code> <span class="type">Boolean</span> Default: <code>true</code> Whether or not to cache the result.</li>
</ul>
</li>
</ul>
</li>
<li><code>initialize</code> <span class="type">Function</span> Default: <code>function () {}</code> An overridable function that will be called as a last step in the instantiation process for your model. It get called with as the constructor got. </li>
</ul>
</li>
</div></ul>
<p><code>extend</code> is the main method you&apos;ll use to create model definitions. It returns a custom constructor that can be used to create instances of your custom model.

</p>
<p>As an example imagine two modules <code>app.js</code> and <code>UserModel.js</code>.

</p>
<p>The contents of <code>UserModel.js</code> defines a model:

</p>
<pre><code class="js">var AmpersandModel = require(&apos;ampersand-model&apos;);

// define a model
var UserModel = AmpersandModel.extend({
    props: {
        name: &apos;string&apos;
    }
});

var user = new User({name: &apos;henrik&apos;});

console.log(user.name); // logs out &apos;henrik&apos;</code></pre>
<h4>.dataTypes</h4>
<p>The dataTypes



</p>
</div>
          <div class="include"><h2>ampersand-state</h2>
<p>An observable, extensible state object with derived watchable properties.

</p>
<p>Ampersand-state serves as a base object for <a href="http://github.com/ampersandjs/ampersand-model">ampersand-model</a> but is useful any time you want to track complex state.

</p>
<p><a href="https://github.com/ampersandjs/ampersand-model">ampersand-model</a> extends ampersand-state to include assumptions that you&apos;d want if you&apos;re using models to model date from a REST API. But by itself ampersand-state is useful for anytime you want something to model state, that fires events for changes and lets you define and listen to derived properties.



</p>
<h3>browser support</h3>
<p><a href="https://ci.testling.com/ampersandjs/ampersand-state"><img src="https://ci.testling.com/ampersandjs/ampersand-state.png" alt="browser support">
</a>

</p>
<h3>install</h3>
<pre><code>npm install ampersand-state</code></pre>
<h3>In pursuit of the ultimate observable JS object.</h3>
<p>So much of building an application is managing state. Your app needs a single unadulterated <em>source of truth</em>. But in order to fully de-couple it from everything that cares about it, it needs to be observable.

</p>
<p>Typically that&apos;s done by allowing you to register handlers for when things change.

</p>
<p>In our case it looks like this:

</p>
<pre><code class="js">// Require the lib
var State = require(&apos;ampersand-state&apos;);

// Create a constructor to represent the state we want to store
var Person = State.extend({
    props: {
        name: &apos;string&apos;,
        isDancing: &apos;boolean&apos;
    }
});

// Create an instance of our object
var person = new Person({name: &apos;henrik&apos;});

// watch it
person.on(&apos;change:isDancing&apos;, function () {
    console.log(&apos;shake it!&apos;); 
});

// set the value and the callback will fire
person.isDancing = true;</code></pre>
<h3>So what?! That&apos;s boring.</h3>
<p>Agreed. Though, there is some more subtle awesomeness in being able to observe changes that are set with a simple assigment: <code>person.isDancing = true</code> as opposed to <code>person.set(&apos;isDancing&apos;, true)</code> (either works, btw), but that&apos;s nothing groundbreaking.

</p>
<p>So, what else? Well, as it turns out, a <em>huge</em> amount of code that you write in a project is really in describing and tracking relationships between variables.

</p>
<p>So, what if our observable layer did that for us too?

</p>
<p>Say you wanted to describe a draggable element on a page so you wanted it to follow a set of a rules. You want it to only be considered to have been dragged if it&apos;s total delta is &gt; 10 pixels.

</p>
<pre><code class="js">var DraggedElementModel = State.extend({
    props: {
        x: &apos;number&apos;,
        y: &apos;number&apos;
    },
    derived: {
        // the name of our derived property
        dragged: {
            // the properties it depends on
            deps: [&apos;x&apos;, &apos;y&apos;],
            // how it&apos;s calculated
            fn: function () {
                // the distance formula
                return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) &gt; 10;
            }
        }
    }
});

var element = new DraggedElementModel({x: 0, y: 0});

// now we can just watch for changes to &quot;dragged&quot;
element.on(&apos;change:dragged&apos;, function (model, val) {
    if (val) {
        console.log(&apos;element has moved more than 10px&apos;);
    } else {
        console.log(&apos;element has moved less than 10px&apos;);
    }
});</code></pre>
<h3>You didn&apos;t invent derived properties, pal. <code>&lt;/sarcasm&gt;</code></h3>
<p>True, derived properties aren&apos;t a new idea. But, being able to clearly declare and derive watchable properties from a model is super useful and in our case, they&apos;re just accessed without calling a method. For example, using the draggable example above, the derived property is just <code>element.dragged</code>.


</p>
<h3>Handling relationships between objects/models with derived properties</h3>
<p>Say you&apos;ve got an observable that you&apos;re using to model data from a RESTful API. Say that you&apos;ve got a <code>/users</code> endpoint and when fetching a user, the user data includes a groupID that links them to another collection of groups that we&apos;ve already fetched and created models for. From our user model we want to be able to easily access the group model. So, when passed to a template we can just access related group information.

</p>
<p>Cached, derived properties are perfect for handling this relationship:

</p>
<pre><code class="js">var UserModel = State.extend({
    props: {
        name: &apos;string&apos;,
        groupId: &apos;string&apos;
    },
    derirved: {
        groupModel: {
            deps: [&apos;groupId&apos;],
            fn: function () {
                // we access our group collection from within 
                // the derived property to grab the right group model.
                return ourGroupCollection.get(this.groupId);
            }
        }
    }
});


var user = new UserModel({name: &apos;henrik&apos;, groupId: &apos;2341&apos;});

// now we can get the actual group model like so:
user.groupModel;

// As a bonus, it&apos;s even evented so you can listen for changes to the groupModel property.
user.on(&apos;change:groupModel&apos;, function (model, newGroupModel) {
    console.log(&apos;group changed!&apos;, newGroupModel);
});</code></pre>
<h3>Cached, derived properties are da shiznit</h3>
<p>So, say you have a more &quot;expensive&quot; computation for model. Say you&apos;re parsing a long string for URLs and turning them into HTML and then wanting to reference that later. Again, this is built in.

</p>
<p>By default, derived properties are cached. 

</p>
<pre><code class="js">// assume this linkifies strings
var linkify = require(&apos;urlify&apos;);

var MySmartDescriptionModel = State.extend({
    // assume this is a long string of text
    description: &apos;string&apos;,
    derived: {
        linkified: {
            deps: [&apos;description&apos;],
            fn: function () {
                return linkify(this.description);
            }
        }
    }
});

var myDescription = new MySmartDescriptionModel({
    description: &quot;Some text with a link. http://twitter.com/henrikjoreteg&quot;
});

// Now i can just reference this as many times as I want but it 
// will never run it through the expensive function again.

myDescription.linkified;</code></pre>
<p>With the model above, the descrition will only be run through that linkifier method once, unless of course the description changes.


</p>
<h3>Derived properties are intelligently triggered</h3>
<p>Just because an underlying property has changed, <em>doesn&apos;t mean the derived property has</em>. 

</p>
<p>Cached derived properties will <em>only</em> trigger a <code>change</code> if the resulting calculated value has changed.

</p>
<p>This is <em>super</em> useful if you&apos;ve bound a derived property to a DOM property. This ensures that you won&apos;t ever touch the DOM unless the resulting value is <em>actually</em> different. Avoiding unecessary DOM changes is a huge boon for performance.

</p>
<p>This is also important for cases where you&apos;re dealing with fast changing attributes.

</p>
<p>Say you&apos;re drawing a realtime graph of tweets from the Twitter firehose, instead of binding your graph to increment with each tweet, if you know your graph only ticks with every thousand tweets you can easily create a property to watch.

</p>
<pre><code class="js">var MyGraphDataModel = State.extend({
    props: {
        numberOfTweets: &apos;number&apos;
    },
    derived: {
        thousandTweets: {
            deps: [&apos;numberOfTweets&apos;],
            fn: function () {
                return Math.floor(this.numberOfTweets / 1000);
            }
        }
    }
});

// then just watch the property
var data = new MyGraphDataModel({numberOfTweets: 555});

// start adding &apos;em
var increment = function () {
    data.number += 1;
}
setInterval(increment, 50);

data.on(&apos;change:thousandTweets&apos;, function () {
    // will only get called every time is passes another 
    // thousand tweets.
});</code></pre>
<h3>Derived properties don&apos;t <em>have</em> to be cached.</h3>
<p>Say you want to calculate a value whenever it&apos;s accessed. Sure, you can create a non-cached derived property.

</p>
<p>If you say <code>cache: false</code> then it will fire a <code>change</code> event anytime any of the <code>deps</code> changes and it will be re-calculated each time its accessed.


</p>
<h3>State can be extended as many times as you want</h3>
<p>Each state object you define will have and <code>extend</code> method on the constructor.

</p>
<p>That means you can extend as much as you want and the definitions will get merged.

</p>
<pre><code class="js">var Person = State.extend({
    props: {
        name: &apos;string&apos;
    },
    sayHi: function () {
        return &apos;hi, &apos; + this.name;
    }
});

var AwesomePerson = Person.extend({
    props: {
        awesomeness: &apos;number&apos;
    }
});

// Now awesome person will have both awesomeness and name properties
var awesome = new AwesomePerson({
    name: &apos;henrik&apos;,
    awesomeness: 8
});

// and it will have the methods in the original
awesome.sayHi(); // returns &apos;hi, henrik&apos;

// it also maintains the prototype chain
// so instanceof checks will work up the chain

// so this is true
awesome instanceof AwesomePerson; // true;

// and so is this
awesome instanceof Person; // true</code></pre>
<h3>child models and collections</h3>
<p>You can declare children and collections that will get instantiated on init as follows:

</p>
<pre><code class="js">var State = require(&apos;ampersand-state&apos;);
var Messages = require(&apos;./models/messages&apos;);
var ProfileModel = require(&apos;./models/profile&apos;);


var Person = State.extend({
    props: {
        name: &apos;string&apos;
    },
    collections: {
        // `Messages` here is a collection
        messages: Messages
    },
    children: {
        // `ProfileModel` is another ampersand-state constructor
        profile: ProfileModel
    }
});

// When we instantiate an instance of a Person 
// the Messages collection and ProfileModels
// are instantiated as well

var person = new Person();

// so meetings exists as an empty collection
person.meetings instanceof Meetings; // true

// and profile exists as an empty `ProfileModel`
person.profile instanceof ProfileModel; // true

// This also provides some additional capabilities
// when we instantiate a state object with some
// data it will apply them to the collections and child
// models as you might expect:
var otherPerson = new Person({
    messages: [
        {from: &apos;someone&apos;, message: &apos;hi&apos;},
        {from: &apos;someoneElse&apos;, message: &apos;yo!&apos;},
    ],
    profile: {
        name: &apos;Joe&apos;, 
        hairColor: &apos;black&apos;
    }
});

// now messages would have a length
otherPerson.messages.length === 2; // true

// and the profile state object would be
// populated
otherPerson.profile.name === &apos;Joe&apos;; // true

// The same works for `set`, it will apply it 
// to children as well. 
otherPerson.set({profile: {name: &apos;Mary&apos;}});

// Since this a state object it triggers a `change:name` on 
// the `profile` object. 
// In addition, since it&apos;s a child that event propagates 
// up. More on that below.</code></pre>
<h3>Event bubbling, derived properties based on children</h3>
<p>Say you want a simple way to listen for any changes that are represented in a tempalate.

</p>
<p>Let&apos;s say you&apos;ve got a <code>person</code> state object with a <code>profile</code> child. You want an easy way to listen for changes to either the base <code>person</code> object or the <code>profile</code>. In fact, you want to listen to anything related to the person object. 

</p>
<p>Rather than having to worry about watching the right thing, we do exactly what the browser does to solve this problem: we bubble up the events up the chain. 

</p>
<p>Now we can listen for deeply nested changes to properties.

</p>
<p>And we can declare derived properties that depend on children. For example:

</p>
<pre><code class="js">var Person = State.extend({
    children: {
        profile: Profile
    },
    derived: {
        childsName: {
            // now we can declare a child as a
            // dependency
            deps: [&apos;profile.name&apos;],
            fn: function () {
                return &apos;my child\&apos;s name is &apos; + this.profile.name;
            }
        }
    }
});

var me = new Person();

// we can listen for changes to the derived property
me.on(&apos;change:childsName&apos;, function (model, newValue) {
    console.log(newValue); // logs out `my child&apos;s name is henrik`
});

// so when a property of a child is changed the callback
// above will be fired (if the resulting derived property is different)
me.profile.name = &apos;henrik&apos;;</code></pre>
<h3>Changelog</h3>
</div>
          <div class="include"><h2>ampersand-collection</h2>
<p>A way to store/manage objects or models.

</p>
<p>Unlike other tools this makes no assumptions about how it&apos;s going to be used or what type of models it is going to contain. This makes it a very flexible/useful tool for modeling all kinds of stuff.

</p>
<p>It does not require underscore or jQuery, but instead makes it easy to extend with those methods if you&apos;d like.



</p>
<h3>browser support</h3>
<p><a href="https://ci.testling.com/ampersandjs/ampersand-collection"><img src="https://ci.testling.com/ampersandjs/ampersand-collection.png" alt="browser support">
</a>

</p>
<h3>install</h3>
<pre><code>npm i ampersand-collection</code></pre>
<h3>massive flexibility</h3>
<p>The collection is a fairly low-level tool, in that it&apos;s useful for any time you want to be able to store JS objects in an array.

</p>
<p>In many ways it&apos;s simply an observable array of objects.

</p>
<p>It emits <code>add</code>, <code>remove</code> events and makes it possible to merge in a set of objects into an existing collection and emit change events appropriately.

</p>
<p>If you extend it with a <code>.model</code> property that contains a constructor, the collection will ensure that objects that don&apos;t match that constructor are instantiated before being added to the collection.

</p>
<p>For example:

</p>
<pre><code class="js">var Collection = require(&apos;ampersand-collection&apos;);

// can just store plain objects
var basicCollection = new Collection([
    {name: &apos;larry&apos;},
    {name: &apos;curly&apos;},
    {name: &apos;moe&apos;}
]);</code></pre>
<p>Adding <a href="http://github.com/AmpersandJS/ampersand-rest-mixin">ampersand-collection-rest-mixin</a> and <a href="http://github.com/AmpersandJS/ampersand-collection-underscore-mixin">ampersand-collection-underscore-mixin</a>. 

</p>
<pre><code class="js">var Collection = require(&apos;ampersand-collection&apos;);
var restMixin = require(&apos;ampersand-collection-rest-mixin&apos;);
var underscoreMixin = require(&apos;ampersand-collection-underscore-mixin&apos;);


// or we can extend it with underscore and REST methods
// to turn it into something similar to a Backbone Collection
var RestfulCollection = Collection.extend(underscoreMixin, restMixin, {
    url: &apos;/mystuff&apos;
});

var collection = new RestfulCollection();

// does ajax request
collection.fetch();</code></pre>
</div>
          <div class="include"><h2>ampersand-rest-collection</h2>
<p>Extends ampersand-collection with REST and Underscore mixins.

</p>
<p>This makes ampersand-collection work and act a lot like Backbone.Collection, if you&apos;re planning on hitting a REST-ful API this is probably what you want to use.

</p>
<h3>browser support</h3>
<p><a href="https://ci.testling.com/AmpersandJS/ampersand-rest-collection"><img src="https://ci.testling.com/AmpersandJS/ampersand-rest-collection.png" alt="testling badge"></a>



</p>
<h3>install</h3>
<pre><code>npm install ampersand-rest-collection</code></pre>
<h3>example</h3>
<p>Define a collection

</p>
<pre><code class="javascript">var Collection = require(&apos;ampersand-rest-collection&apos;);
var Model = require(&apos;some-model&apos;);


module.exports = Collection.extend({
    model: Model,
    url: &apos;/models&apos;
});</code></pre>
<p>Using it:

</p>
<pre><code class="javascript">var Collection = require(&apos;./path-to-your-collection-module&apos;);


var c = new Collection();

// call RESTful methods
c.fetch();

// also has underscore mixins
c.each(function (model) {
    console.log(&apos;model:&apos;, model);
});</code></pre>
</div>
          <div class="include"><h2>ampersand-sync</h2>
<p>Standalone, modern-browser-only version of Backbone.Sync as Common JS module.

</p>
<p>You probably won&apos;t use this directly, but it is used by ampersand-model and ampersand-rest-collection to provide the REST functionality.

</p>
<h3>browser support</h3>
<p><a href="https://ci.testling.com/AmpersandJS/ampersand-sync"><img src="https://ci.testling.com/AmpersandJS/ampersand-sync.png" alt="testling badge"></a>



</p>
<h3>install</h3>
<pre><code>npm install ampersand-sync</code></pre>
<h3>running the tests</h3>
<pre><code>npm test</code></pre>
<p>Tests are written in <a href="https://github.com/substack/tape">tape</a> and since they require a browser environment it gets run in a headless browser using phantomjs via <a href="https://github.com/juliangruber/tape-run">tape-run</a>. Make sure you have phantomjs installed for this to work. 

</p>
<p>You can also run <code>npm start</code> then open a browser.


</p>
</div>
          <div class="include"><h2>ampersand-view</h2>
<p>A set of common helpers and conventions for using as a base view for ampersand.js apps.

</p>
<p>What does it do?

</p>
<ol>
<li>Gives you a proven pattern for managing/binding the contents of an element.</li>
<li>Simple declarative property/template bindings without needing to include a template engine that does it for you. This keeps your logic out of your templates and lets you use a string of HTML as a fully dynamic template or just a simple function that returns an HTML string.</li>
<li>The view&apos;s base element is replaced (or created) during a render. So, rather than having to specify tag type and attributes in javascript in the view definition you can just include that in your template like everything else.</li>
<li>A way to render a collection of models within an element in the view, each with their own view, preserving order, and doing proper cleanup when the main view is removed.</li>
<li>A simple way to render sub-views that get cleaned up when the parent view is removed.</li>
</ol>
<h3>Browser support</h3>
<p><a href="https://ci.testling.com/ampersandjs/ampersand-view"><img src="https://ci.testling.com/ampersandjs/ampersand-view.png" alt="browser support">
</a>

</p>
<h3>Install</h3>
<pre><code>npm install ampersand-view</code></pre>
<h3>Usage</h3>
<h4>Basics</h4>
<p>Nothing special is required, just use <code>AmpersandView</code> in the same way as you would Backbone.View:

</p>
<pre><code class="javascript">var MyView = AmpersandView.extend({
    initialize: function () { ... }, 
    render: function () { ... }
});</code></pre>
<h4>Declarative Bindings</h4>
<pre><code class="javascript">var MyView = AmpersandView.extend({
    // set a `template` property of your view. This can either be
    // a function that returns an HTML string or just a string if 
    // no logic is required.
    template: &apos;&lt;li&gt;&lt;a&gt;&lt;span class=&quot;userName&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&apos;, 
    // Simple declarative bindings
    // The key is the name of the model property
    bindings: {
        // the value is a selector, by default a text binding is assumed
        // this would keep the model&apos;s `name` attribute in the span, even
        // if it&apos;s changed.
        name: &apos;.userName&apos;,

        // If the `active` property is a boolean the class 
        // will be added/removed based on the boolean property.
        // But, if the `active` property were a string, the previous
        // value would be removed and the new one added from the class
        // list without affecting other classes that may alreay be there.
        active: [&apos;li&apos;, &apos;class&apos;],

        // If you&apos;ve got a boolean property, you can also specify a third
        // item in the array. It will be used to determine what the class
        // is that will be toggled. This way your property name can be 
        // different than the class. 
        isActive: [&apos;li&apos;, &apos;class&apos;, &apos;active&apos;], // will toggle the &apos;active&apos; class

        // If you prefer, you *can* also bind to the whole class list. Which
        // will wipe out all existing classes.
        myClasses: [&apos;li&apos;, &apos;classList&apos;],

        // As you might have guessed, you can bind to any attribute you want
        userUrl: [&apos;a&apos;, &apos;href&apos;],

        // This works for boolean attributes. The following would add and remove 
        // the entire `checked` attribute (assuming the property value was a boolean)
        selected: [&apos;input&apos;, &apos;checked&apos;]

        // If you really need to, you can even bind the same attribute to different
        // types of things with different options. If &quot;superActive&quot; was a string, the following would put
        // the text value of it, inside `.userName` and add it as a class on the `li`.
        superActive: [
            // the *only* restriction here is that if you pass an array of binding
            // declarations for a single property, each sub-item must also be an
            // array.
            [&apos;.userName&apos;],
            [&apos;li&apos;, &apos;class&apos;],
            // you can even get crazy... this would bind both
            // data attributes to both the li and .username elements
            [&apos;li, .username&apos;, &apos;data-attribute1 data-attribute2&apos;],
        ]        
    },
    render: function () {
        // method for rendering the view&apos;s template and binding all
        // the model properties as described by `textBindings` above.
        // You can also bind other attributes, and if you&apos;re using
        // ampersand-model, you can bind derived properties too.
        this.renderAndBind({what: &apos;some context object for the template&apos;});
    }
});</code></pre>
<h4>What about two-way bindings?</h4>
<p>Note that these are all one-way bindings. People love to talk about the feature of two-way bindings, but from my experience, the vast majority of the time it&apos;s not actually something that you want. Why make two different ways of doing the same thing? The most common two-way bindings that people do are for form elements, which, is super easy to do with the events hash. Plus, then it&apos;s very easy to configure exactly when you want the user action to actually change the model.

</p>
<p>Having said that, we may enable it anyway, in a future release, that&apos;s still up for discussion.


</p>
<h4>handling subviews</h4>
<p>Often you want to render some other subview within a view. The trouble is that when you remove the parent view, you also want to remove all the subviews.

</p>
<p>AmpersandView has two convenience method for handling this that&apos;s also used by <code>renderCollection</code> to do cleanup.

</p>
<p>It looks like this:

</p>
<pre><code class="javascript">var AmpersandView = require(&apos;ampersand-view&apos;);

// This can be *anything* with a `remove` method
// and an `el` property... such as another ampersand-view
// instance.
// But you could very easily write other little custom views
// that followed the same conventions. Such as custom dialogs, etc.
var SubView = require(&apos;./my-sub-view&apos;);

module.exports = AmpersandView.extend({
    render: function () {
        // this takes a view instance and either an element, or element selector 
        // to draw the view into.
        this.renderSubview(new Subview(), &apos;.someElementSelector&apos;);

        // There&apos;s an even lower level api that `renderSubview` usees
        // that will do nothing other than call `remove` on it when
        // the parent view is removed.
        this.registerSubview(new Subview());
    }
})</code></pre>
<p><strong>registerSubview also, stores a reference to the parent view on the subview as <code>.parent</code></strong>



</p>
<h3>API Reference</h3>
<p>Note that this is a fork of Backbone&apos;s view so most of the public methods/properties here still exist: <a href="http://backbonejs.org/#View">http://backbonejs.org/#View</a>

</p>
<h4>.template</h4>
<p>The <code>.template</code> is a property for the view prototype. It should either be a string of HTML or a function that returns a string of HTML. It isn&apos;t required, but it is used as a default for calling <code>renderAndBind</code> and <code>renderWithTemplate</code>.

</p>
<p>The important thing to note is that the <em>HTML should not have more than one root element</em>. This is because the view code assumes that it has one and only one root element that becomes the <code>.el</code> property of the instantiated view.

</p>
<h4>.autoRender</h4>
<p>The <code>.autoRender</code> property lets you optionally specify that the view should just automatically render with all the defaults. This requires that you at minimum specify a <a href="#template">template</a> string of function.

</p>
<p>By setting <code>autoRender: true</code> the view will simply call <code>.renderAndBind</code> for you (after your <code>initialize</code> method if present). So for simple views, if you&apos;ve got a few bindings and a template your whole view could just be really and declarative like this:


</p>
<pre><code class="js">var AmpersandView = require(&apos;ampersand-view&apos;);


module.exports = AmpersandView.extend({
    autoRender: true,
    template: &apos;&lt;div&gt;&lt;span id=&quot;username&quot;&gt;&lt;/span&gt;&lt;/div&gt;&apos;,
    bindings: {
        name: &apos;#username&apos;
    } 
});</code></pre>
<p><strong>Note:</strong> if you are using a template function (and not a string) the template function will get called with a context argument that looks like this:

</p>
<pre><code class="js">this.renderAndBind({
    model: this.model,
    collection: this.collection
}, this.template);</code></pre>
<h4>.renderCollection(collection, ItemView, containerEl, [viewOptions])</h4>
<div class="signature"><ul>
<li><code>collection</code> <span class="type">Backbone Collection</span> The instantiated collection we wish to render.</li>
<li><code>itemViewClass</code> <span class="type">View Constructor</span> The view constructor that will be instantiated for each model in the collection. This view will be instantiated with a reference to the model and collection and the item view&apos;s <code>render</code> method will be called with an object containing a reference to the containerElement as follows: <code>.render({containerEl: &lt;&lt; element &gt;&gt;})</code>.</li>
<li><code>containerEl</code> <span class="type">Element</span> The element that should hold the collection of views.</li>
<li><code>viewOptions</code> <span class="type">Object</span> [optional] Additional options <ul>
<li><code>viewOptions</code> <span class="type">Object</span> Options object that will get passed to the <code>initialize</code> method of the individual item views.</li>
<li><code>filter</code> <span class="type">Function</span> [optional] Function that will be used to determine if a model should be rendered in this collection view. It will get called with a model and you simply return <code>true</code> or <code>false</code>.</li>
<li><code>reverse</code> <span class="type">Boolean</span> [optional] Convenience for reversing order in which the items are rendered.</li>
</ul>
</li>
</div></ul>
<p>This method will maintain this collection within that container element. Including proper handling of add, remove, sort, reset, etc. 

</p>
<p>Also, when the parent view gets <code>.remove()</code>&apos;ed any event handlers registered by the individual item views will be properly removed as well. 

</p>
<p>Each item view will only be <code>.render()</code>&apos;ed once (unless you change that within the item view itself).

</p>
<h5>Example:</h5>
<pre><code class="javascript">// some view for individual items in the collection
var ItemView = AmpersandView.extend({ ... });

// the main view
var MainView = AmpersandView.extend({
    template: &apos;&lt;section class=&quot;page&quot;&gt;&lt;ul class=&quot;itemContainer&quot;&gt;&lt;/ul&gt;&lt;/section&gt;&apos;,
    render: function (opts) {
        // render our template as usual
        this.renderAndBind();

        // call renderCollection with these arguments:
        // 1. collection
        // 2. which view to use for each item in the list
        // 3. which element within this view to use as the container
        // 4. options object (not required):
        //      {
        //          // function used to determine if model should be included
        //          filter: function (model) {},
        //          // boolean to specify reverse rendering order
        //          reverse: false,
        //          // view options object (just gets passed to item view&apos;s `initialize` method)
        //          viewOptions: {}
        //      }
        this.renderCollection(this.collection, ItemView, this.$(&apos;.itemContainer&apos;)[0], opts);
        return this;
    }  
})</code></pre>
<h4>.registerSubview(viewInstance)</h4>
<div class="signature"><ul>
<li>viewInstance <span class="type">Object</span> Any object with a &quot;remove&quot; method, typically an instantiated view. But doesn&apos;t have to be, it can be anything with a remove method. The remove method doesn&apos;t have to actually remove itself from the DOM (since the parent view is being removed anyway), it is generally just used for unregistering any handler that it set up.</li>
</div></ul>
<h4>.renderSubview(viewInstance, containerEl)</h4>
<div class="signature"><ul>
<li>viewInstance <span class="type">Object</span> Any object with a <code>.remove()</code>, <code>.render()</code> and an <code>.el</code> property that is the DOM element for that view. Typically this is just an instantiated view. </li>
<li>containerEl <span class="type">Element | String | jQueryElement</span> This can either be an actual DOM element or a CSS selector string such as <code>.container</code>. If a string is passed human view runs <code>this.$(&quot;YOUR STRING&quot;)</code> to try to grab the element that should contain the sub view.</li>
</div></ul>
<p>This method is just sugar for the common use case of instantiating a view and putting in an element within the parent.

</p>
<p>It will:

</p>
<ol>
<li>fetch your container (if you gave it a selector string)</li>
<li>register your subview so it gets cleaned up if parent is removed and so <code>view.parent</code> will be available when your subview&apos;s <code>render</code> method gets called</li>
<li>call the subview&apos;s <code>render()</code> method</li>
<li>append it to the container</li>
<li>return the subview</li>
</ol>
<h5>Example:</h5>
<pre><code class="js">var view = AmpersandView.extend({
    template: &apos;&lt;li&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/li&gt;&apos;,
    render: function () {
        this.renderAndBind();

        ...

        var model = this.model;
        this.renderSubview(new SubView({
            model: model
        }), &apos;.container&apos;);

        ... 

    } 
});</code></pre>
<h4>.renderAndBind([context], [template])</h4>
<div class="signature"><ul>
<li><code>context</code> <span class="type">Object | null</span> [optional] The context that will be passed to the template function, usually <code>{model: this.model}</code>.</li>
<li><code>template</code> <span class="type">Function | String</span> [optional] A function that returns HTML or a string of HTML.</li>
</div></ul>
<p>This is shortcut for the default rendering you&apos;re going to do in most every render method, which is: use the template property of the view to replace <code>this.el</code> of the view and re-register all handlers from the event hash and any other binding as described above.

</p>
<h5>Example:</h5>
<pre><code class="js">var view = AmpersandView.extend({
    template: &apos;&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;&apos;,
    bindings: {
        &apos;name&apos;: &apos;a&apos;
    },
    events: {
        &apos;click a&apos;: &apos;handleLinkClick&apos;
    },
    render: function () {
        // this does everything
        // 1. renders template
        // 2. registers delegated click handler
        // 3. inserts and binds the &apos;name&apos; property
        //    of the view&apos;s `this.model` to the &lt;a&gt; tag.
        this.renderAndBind();
    }
});</code></pre>
<h4>.renderWithTemplate([context], [template])</h4>
<div class="signature"><ul>
<li><code>context</code> <span class="type">Object | null</span> The context object that will be passed to the template function if it&apos;s a function.</li>
<li><code>template</code> <span class="type">Function | String</span> [optional] template function that returns a string of HTML or a string of HTML. If it&apos;s not passed, it will default to the <code>template</code> property in the view.</li>
</div></ul>
<p>This is shortcut for doing everything we need to do to render and fully replace current root element with the template that our view is wanting to render. In typical backbone view approaches you never replace the root element. But from our experience, it&apos;s nice to see the <em>entire</em> html structure represented by that view in the template code. Otherwise you end up with a lot of wrapper elements in your DOM tree.

</p>
<h4>.getByRole(name)</h4>
<div class="signature"><ul>
<li><code>name</code> <span class="type">String</span> The name of the &apos;role&apos; attribute we&apos;re searching for.</li>
</div></ul>
<p>This is for convenience and also to encourage the use of the <code>role</code> attribute for grabbing elements from the view. Using roles to select elements in your view makes it much less likely that designers and JS devs accidentally break each other&apos;s code. This will work even if the <code>role</code> attribute is on the view&apos;s root <code>el</code>.

</p>
<h5>Example:</h5>
<pre><code class="js">var view = AmpersandView.extend({
    template: &apos;&lt;li&gt;&lt;img role=&quot;avatar&quot; src=&quot;/user.png&quot;/&gt;&lt;/li&gt;&apos;,
    render: function () {
        this.renderAndBind();

        // cache an element for easy reference by other methods
        this.imgEl = this.getByRole(&apos;avatar&apos;);
    } 
});</code></pre>
<h3>Changelog</h3>
<div class="signature"><ul>
<li>1.6.3 <a href="https://github.com/HenrikJoreteg/ampersand-view/compare/v1.6.2...v1.6.3">diff</a> - Move throw statment for too many root elements inside non <code>&lt;body&gt;</code> case.</li>
<li>1.6.2 <a href="https://github.com/HenrikJoreteg/ampersand-view/compare/v1.6.1...v1.6.2">diff</a> - Make <code>getByRole</code> work even if <code>role</code> attribute is on the root element. Throws an error if your view template contains more than one root element.</li>
<li>1.6.1 <a href="https://github.com/HenrikJoreteg/ampersand-view/compare/v1.6.0...v1.6.1">diff</a> - Make sure renderSubview registers the subview first, so it has a <code>.parent</code> before it calls <code>.render()</code> on the subview.</li>
<li>1.6.0 <a href="https://github.com/HenrikJoreteg/ampersand-view/compare/v1.5.0...v1.6.0">diff</a> - Adding <code>getByRole</code> method</li>
<li>1.5.0 - Adding bower.json, adding missing dev dependencies, other small bugfixes.</li>
<li>1.4.1 - Removing elements without using jQuery&apos;s <code>.empty()</code> in renderCollection. (fixes: <a href="https://github.com/HenrikJoreteg/ampersand-view/issues/13">https://github.com/HenrikJoreteg/ampersand-view/issues/13</a>)</li>
<li>1.4.0 - Adding <code>parent</code> reference to subviews registered via registerSubview</li>
</div></ul>
</div>
          <div class="include"><h2>ampersand-router</h2>
<p>Clientside router with fallbacks for browsers that don&apos;t support pushState. Mostly lifted from Backbone.js.



</p>
<h3>install</h3>
<pre><code>npm install ampersand-router</code></pre>
<h3>example</h3>
<pre><code class="javascript">var Router = require(&apos;ampersand-router&apos;);


module.exports = Router.extend({
    routes: {
        &apos;&apos;: &apos;home&apos;,
        &apos;collections/:id&apos;: &apos;collections&apos;,
        &apos;info&apos;: &apos;info&apos;
    },

    // ------- ROUTE HANDLERS ---------
    home: function () {
        this.trigger(&apos;newPage&apos;, new HomePage());
    },

    ...
}};</code></pre>
</div>
          <div class="include"><h2>ampersand-registry</h2>
<p>Global model registry for tracking instantiated models accross collections.

</p>
<p>This isn&apos;t necessary for most apps, but sometimes it&apos;s useful to create a global registry of all or a subset of instantiated models in your application. This can be useful when realtime applications where you&apos;re getting incoming events with IDs and model types and need some global way to look up models in your application.

</p>
<p>The code is quite short and simple it&apos;s only ~50 lines. It may be easiest to just read the code for documetation. But some examples/explanations are included below.



</p>
<h3>install</h3>
<pre><code>npm install ampersand-registry</code></pre>
<h3>browser support</h3>
<p><a href="https://ci.testling.com/AmpersandJS/ampersand-registry"><img src="https://ci.testling.com/AmpersandJS/ampersand-registry.png" alt="testling badge"></a>

</p>
<h3>example</h3>
<pre><code class="javascript">var Registry = require(&apos;ampersand-registry&apos;);
var Model = require(&apos;ampersand-model&apos;);

// a singleton model registry
window.registry = new Registry();

// then whenever we&apos;re defining models for our application
// if we&apos;re using ampersand-model or it&apos;s lower level cousin
// ampersand-state we can pass it the registry as part of the
// definition.

var MyModel = Model.extend({
    type: &apos;user&apos;,
    props: {
        name: &apos;string&apos;
    },
    // Pass the registry you want all the instances of this model
    // to be included in.
    registry: window.registry

    // can also be a function in case it&apos;s not defined yet
    registry: function () {
        return window.registry;
    } 
});</code></pre>
<p>After doing this all instantiated models will be put into the registry based on their <code>type</code> property and be removed when destroyed.

</p>
<p>Then the registry can be used to look up models as follows:

</p>
<pre><code class="javascript">// explicitly storing a model
// (if you declare them in your models this isn&apos;t necessary) 
// this will use the models `type`, `getId`, and `namespace` 
// properties to store this accordingly.
registry.store(model);

// get a model
registry.lookup(&apos;{{model type}}&apos;, &apos;{{ model id }}&apos;, &apos;{{ optional namespace }}&apos;);

// remove a stored model from the store by type, id and optionally namespace
registry.remove(&apos;{{model type}}&apos;, &apos;{{ model id }}&apos;, &apos;{{ optional namespace }}&apos;);

// de-reference all models
registry.clear();</code></pre>
</div>
        </section>
        <section>
          <h2 data-nav="View Conventions">View Conventions</h2>
          <p>The core purpose of a view is to manage the contents, events, and behavior or a single DOM element.</p>
          <p>In ampersand, <strong>a "view" doesn't have to actually be an "amperand-view"</strong> at all.</p>
          <p>But in order to maintain the ability to write a collection renderer or to be able to render sub-views it's useful to have a few simple conventions we follow.</p>
          <p><strong>Any</strong> object can be a view if it follows a few rules. Following these rules ensure that that your view plays nicely with other views.</p>
          <p>The rules are most easily explained by an example, here is an absolutely bare-minimum `view`:</p>
          <p>
            <pre class="javascript"><code>function MinimalView(options) {
    // If given an element as part of an options object
    // the view *should* store an element as `this.el`.
    this.el = options.el;
}

// All views should have a `render` method that creates, replaces, or 
// fills in the `this.el` property.
// If passed in when created this view may already have a `this.el`. 
// If so, your render would method would populate it, or create a new
// one and replace it (if already part of the DOM tree).
MinimalView.prototype.render = function () {
    // The important thing is after calling `render` the view should have
    // a `this.el` that is a *real* DOM element.
    this.el.textContent = 'hello, awesome developer!';
};

// It should have a `remove` method that does any tear down you may want
// to do. Including ideally removing itself from it's parent (if reasonable to do so)
MinimalView.prototype.remove = function () {
    // you could do it with vanilla JS like this
    var parent = this.el.parentNode;
    if (parent) parent.removeChild(this.el);
    
    // ...or if you're using jQUery you could just do
    $(this.el).remove();
};
</code></pre>
          </p>
          <p>That's it! </p>
        </section>
        <section>
          <h2 data-nav="moonboots">Moonboots</h2>
          <p>Moonboots is a tool to help you intelligently deal with different goals of serving JS during development and in production.</p>
          <p>In development we explicitly don't want to cache or minify our JS and CSS files while working. We want to organize our modules in a way that makes the most sense for us as we're building the app.</p>
          <p>In production, we want to use the exact same source code structure to generate a single minified, uniquely named file for the JS and the CSS so we can tell the browser to cache those permanently. If we do our job correctly when serving those files, our main application code will be downloaded once per revision of the app.</p>
          <p>Moonboots aims to solve this problem. You structure your entire application in the same way that you would in node with Common JS modules requiring each other. It uses browserify under the hood to do all that magic. But then you just configure your client application like so: </p>
          <h3>Moonboots and Express.js</h3>
          <p>The full documentation for moonboots is <a href="https://github.com/henrikjoreteg/moonboots#readme">available in the Moonboots repo</a>.</p>
          <p>For a preview, here's how we'd configure a clientside moonboots app to be served by Express:</p>
          <pre><code class="js">var express = require('express'),
    Moonboots = require('moonboots'),
    app = express();
    
// configure our app
var clientApp = new Moonboots({
    main: __dirname + '/sample/app/app.js',
    developmentMode: false,
    libraries: [
        __dirname + '/sample/libraries/jquery.js'
    ],
    stylesheets: [
        __dirname + '/styles.css'
    ],
    server: app
});

// We also just need to specify the routes at which we want to serve this clientside app.
// This is important for supporting "deep linking" into a single page app. The server
// has to know what urls to let the browser app handle.
app.get('*', clientApp.html());

// start listening for http requests
app.listen(3000);
</code></pre>
          <h3>Moonboots and Hapi</h3>
          <p>If you're using hapi, there's <a href="https://github.com/wraithgar/moonboots-hapi">a version of Moonboots that is structured as a Hapi plugin</a>.</p>
        </section>
        <section>
          <h2>Finding modules</h2>
          <p>There's a site containing a curated list of npm-installable modules with a quick filter box:  <a href="http://tools.ampersandjs.com">humanjs-resources</a> that should help you find things you may need. </p>
          <p>Also, there are lots of modules you can find via <a href="http://browserify.org/search">browserify's module search</a>.</p>
        </section>
        <section>
          <h2>Examples</h2>
          <h3>And Bang</h3>
          <p>And Bang helps same-page-ify your team with shared tasks and chat. </p>
          <p>Many of the tools and approaches of human javascript were extracted from And Bang.</p><a href="http://andbang.com" class="image-wrapper"><img src="https://i.cloudup.com/p3kLPyMYDw-2000x2000.png" width="400" class="exampleImage"></a>
          <h3>Talky</h3>
          <p>Talky is truly simple video chat and screen sharing app for groups.</p>
          <p>Powered by WebRTC and built on Human Javascript.</p><a href="https://talky.io" class="image-wrapper"><img src="https://i.cloudup.com/0c5WD7hIUb-2000x2000.png" width="400" class="exampleImage"></a>
          <h3>The Resources App</h3>
          <p>Quick module search of curated modules. The source for this app is <a href="https://github.com/henrikjoreteg/humanjs-resources">available on Github</a>.</p><a href="http://resources.humanjavascript.com" class="image-wrapper"><img src="https://i.cloudup.com/XhYHvX7FA5-2000x2000.png" width="400" class="exampleImage"></a>
          <h3>Otalk</h3>
          <p>Otalk is an open source chat client powered XMPP, stanza.io, and WebRTC. You can think of it as an open source alternative to Skype.</p><a href="https://otalk.im" class="image-wrapper"><img src="https://i.cloudup.com/u0xhQors8G-2000x2000.png" width="400" class="exampleImage"></a>
        </section>
        <section>
          <h2>Contributors</h2>
          <p>Ampersand.js is the combined efforts of lots of people and since all these projects are open source there are simply too many contributors to list. </p>
          <p>The project is sponsored by <a href="http://andyet.com">&amp;yet</a>.</p>
          <p>The core contributor team consists of:</p>
          <ul>
            <li><a href="http://twitter.com/henrikjoreteg">Henrik Joreteg</a></li>
            <li><a href="http://twitter.com/lukekarrys">Luke Karrys</a></li>
            <li><a href="http://twitter.com/lancestout">Lance Stout</a></li>
            <li><a href="http://twitter.com/philip_roberts">Philip Roberts</a></li>
            <li><a href="http://twitter.com/_crossdiver">Isaac Lewis</a></li>
            <li><a href="http://twitter.com/wraithgar">Michael (Gar) Garvin</a></li>
          </ul>
          <p>If you have benefitted from these tools, please consider <a href="http://humanjavascript.com">buying the book </a> or  <a href="http://andyet.com">hiring &amp;yet</a> to help with your next development project.</p>
        </section>
      </main>
    </div>
    <script src="static/js/highlight.pack.js"></script>
    <script src="static/js/slugger.js"></script>
    <script src="static/js/setup.js"></script>
    <script src="http://static.andyet.com/tag.js"></script>
  </body>
</html>